<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span id="%24con2tag_6SkmeRYXGqiKPMNOxLZrf9"><span id="%24maxtag_GxYdmMTVw3sFElLs6zUy0j"><span id="%24tag2con_GxYdmMTVw3sFElLs6zUy0j"><span id="%24con2tag_GxYdmMTVw3sFElLs6zUy0j"><span id="%24con2tag_BOeZgGdIUSuGbhwPkOK8Dd"></span></span></span></span></span><span class="hs-pragma">{-# LANGUAGE DeriveDataTypeable #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><span id="line-3"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-4"></span><span class="hs-comment">-- |</span><span>
</span><span id="line-5"></span><span class="hs-comment">-- Module      :  Language.Haskell.Exts.Extension</span><span>
</span><span id="line-6"></span><span class="hs-comment">-- Copyright   :  (c) Niklas Broberg 2009</span><span>
</span><span id="line-7"></span><span class="hs-comment">-- License     :  BSD-style (see the file LICENSE.txt)</span><span>
</span><span id="line-8"></span><span class="hs-comment">--</span><span>
</span><span id="line-9"></span><span class="hs-comment">-- Maintainer  :  Niklas Broberg, niklas.broberg@chalmers.se</span><span>
</span><span id="line-10"></span><span class="hs-comment">-- Stability   :  transient</span><span>
</span><span id="line-11"></span><span class="hs-comment">-- Portability :  portable</span><span>
</span><span id="line-12"></span><span class="hs-comment">--</span><span>
</span><span id="line-13"></span><span class="hs-comment">-- This module defines the list of recognized modular features</span><span>
</span><span id="line-14"></span><span class="hs-comment">-- of Haskell, most often (sloppily) referred to as &quot;extensions&quot;.</span><span>
</span><span id="line-15"></span><span class="hs-comment">--</span><span>
</span><span id="line-16"></span><span class="hs-comment">-- Closely mimicking the Language.Haskell.Extension module from</span><span>
</span><span id="line-17"></span><span class="hs-comment">-- the Cabal library, this package also includes functionality for</span><span>
</span><span id="line-18"></span><span class="hs-comment">-- &quot;computing&quot; languages as sets of features. Also, we make no</span><span>
</span><span id="line-19"></span><span class="hs-comment">-- promise not to add extensions not yet recognized by Cabal.</span><span>
</span><span id="line-20"></span><span class="hs-comment">--</span><span>
</span><span id="line-21"></span><span class="hs-comment">-----------------------------------------------------------------------------</span><span>
</span><span id="line-22"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Language.Haskell.Exts.Extension</span><span> </span><span class="hs-special">(</span><span>
</span><span id="line-23"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Language definitions</span></span><span>
</span><span id="line-24"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier">Language</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-25"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#knownLanguages"><span class="hs-identifier">knownLanguages</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-26"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyLanguage"><span class="hs-identifier">classifyLanguage</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-27"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyLanguage"><span class="hs-identifier">prettyLanguage</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Extensions</span></span><span>
</span><span id="line-30"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier">Extension</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier">KnownExtension</span></a></span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-31"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyExtension"><span class="hs-identifier">classifyExtension</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-32"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#parseExtension"><span class="hs-identifier">parseExtension</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyExtension"><span class="hs-identifier">prettyExtension</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-33"></span><span>
</span><span id="line-34"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Extension groups</span></span><span>
</span><span id="line-35"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ghcDefault"><span class="hs-identifier">ghcDefault</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#glasgowExts"><span class="hs-identifier">glasgowExts</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-36"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#knownExtensions"><span class="hs-identifier">knownExtensions</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#deprecatedExtensions"><span class="hs-identifier">deprecatedExtensions</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-37"></span><span>
</span><span id="line-38"></span><span>    </span><span class="annot"><span class="hs-comment">-- * Semantics of extensions applied to languages</span></span><span>
</span><span id="line-39"></span><span>    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#impliesExts"><span class="hs-identifier">impliesExts</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#toExtensionList"><span class="hs-identifier">toExtensionList</span></a></span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span class="hs-cpp">

#if __GLASGOW_HASKELL__ &lt; 710
</span><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control.Applicative</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator">&lt;|&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span class="hs-cpp">
#else
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Applicative</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&lt;|&gt;)</span></span><span class="hs-special">)</span><span class="hs-cpp">
#endif
</span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Array</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Array</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">accumArray</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">bounds</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">Ix</span></span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">inRange</span></span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">!</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-49"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.List</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">nub</span></span><span class="hs-special">)</span><span>
</span><span id="line-50"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Maybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">fromMaybe</span></span><span class="hs-special">)</span><span>
</span><span id="line-51"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Data</span></span><span>
</span><span id="line-52"></span><span>
</span><span id="line-53"></span><span class="hs-comment">-- Copyright notice from Cabal's Language.Haskell.Extension,</span><span>
</span><span id="line-54"></span><span class="hs-comment">-- from which we borrow plenty of features:</span><span>
</span><span id="line-55"></span><span>
</span><span id="line-56"></span><span class="hs-comment">{- All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of Isaac Jones nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
&quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. -}</span><span>
</span><span id="line-85"></span><span>
</span><span id="line-86"></span><span class="hs-keyword">data</span><span> </span><span id="Language"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier hs-var">Language</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-87"></span><span>
</span><span id="line-88"></span><span>  </span><span class="hs-comment">-- | The Haskell 98 language as defined by the Haskell 98 report.</span><span>
</span><span id="line-89"></span><span>  </span><span class="hs-comment">-- &lt;http://haskell.org/onlinereport/&gt;</span><span>
</span><span id="line-90"></span><span>     </span><span id="Haskell98"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Haskell98"><span class="hs-identifier hs-var">Haskell98</span></a></span></span><span>
</span><span id="line-91"></span><span>
</span><span id="line-92"></span><span>  </span><span class="hs-comment">-- | The Haskell 2010 language as defined by the Haskell 2010 report.</span><span>
</span><span id="line-93"></span><span>  </span><span class="hs-comment">-- &lt;http://www.haskell.org/onlinereport/haskell2010&gt;</span><span>
</span><span id="line-94"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Haskell2010"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Haskell2010"><span class="hs-identifier hs-var">Haskell2010</span></a></span></span><span>
</span><span id="line-95"></span><span>
</span><span id="line-96"></span><span>  </span><span class="hs-comment">-- | The minimal language resulting from disabling all recognized</span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-comment">-- extensions - including ones that are part of all known language</span><span>
</span><span id="line-98"></span><span>  </span><span class="hs-comment">-- definitions e.g. MonomorphismRestriction.</span><span>
</span><span id="line-99"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HaskellAllDisabled"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#HaskellAllDisabled"><span class="hs-identifier hs-var">HaskellAllDisabled</span></a></span></span><span>
</span><span id="line-100"></span><span>
</span><span id="line-101"></span><span>  </span><span class="hs-comment">-- | An unknown language, identified by its name.</span><span>
</span><span id="line-102"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnknownLanguage"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnknownLanguage"><span class="hs-identifier hs-var">UnknownLanguage</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-103"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679387024"><span id="local-6989586621679387026"><span id="local-6989586621679387028"><span class="annot"><span class="annottext">Int -&gt; Language -&gt; ShowS
[Language] -&gt; ShowS
Language -&gt; String
(Int -&gt; Language -&gt; ShowS)
-&gt; (Language -&gt; String) -&gt; ([Language] -&gt; ShowS) -&gt; Show Language
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Language] -&gt; ShowS
$cshowList :: [Language] -&gt; ShowS
show :: Language -&gt; String
$cshow :: Language -&gt; String
showsPrec :: Int -&gt; Language -&gt; ShowS
$cshowsPrec :: Int -&gt; Language -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679387015"><span id="local-6989586621679387017"><span id="local-6989586621679387019"><span id="local-6989586621679387021"><span class="annot"><span class="annottext">ReadPrec [Language]
ReadPrec Language
Int -&gt; ReadS Language
ReadS [Language]
(Int -&gt; ReadS Language)
-&gt; ReadS [Language]
-&gt; ReadPrec Language
-&gt; ReadPrec [Language]
-&gt; Read Language
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
readListPrec :: ReadPrec [Language]
$creadListPrec :: ReadPrec [Language]
readPrec :: ReadPrec Language
$creadPrec :: ReadPrec Language
readList :: ReadS [Language]
$creadList :: ReadS [Language]
readsPrec :: Int -&gt; ReadS Language
$creadsPrec :: Int -&gt; ReadS Language
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679387010"><span id="local-6989586621679387012"><span class="annot"><span class="annottext">Language -&gt; Language -&gt; Bool
(Language -&gt; Language -&gt; Bool)
-&gt; (Language -&gt; Language -&gt; Bool) -&gt; Eq Language
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Language -&gt; Language -&gt; Bool
$c/= :: Language -&gt; Language -&gt; Bool
== :: Language -&gt; Language -&gt; Bool
$c== :: Language -&gt; Language -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386994"><span id="local-6989586621679386996"><span id="local-6989586621679386998"><span id="local-6989586621679387000"><span id="local-6989586621679387002"><span id="local-6989586621679387004"><span id="local-6989586621679387006"><span class="annot"><span class="annottext">Eq Language
Eq Language
-&gt; (Language -&gt; Language -&gt; Ordering)
-&gt; (Language -&gt; Language -&gt; Bool)
-&gt; (Language -&gt; Language -&gt; Bool)
-&gt; (Language -&gt; Language -&gt; Bool)
-&gt; (Language -&gt; Language -&gt; Bool)
-&gt; (Language -&gt; Language -&gt; Language)
-&gt; (Language -&gt; Language -&gt; Language)
-&gt; Ord Language
Language -&gt; Language -&gt; Bool
Language -&gt; Language -&gt; Ordering
Language -&gt; Language -&gt; Language
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Language -&gt; Language -&gt; Language
$cmin :: Language -&gt; Language -&gt; Language
max :: Language -&gt; Language -&gt; Language
$cmax :: Language -&gt; Language -&gt; Language
&gt;= :: Language -&gt; Language -&gt; Bool
$c&gt;= :: Language -&gt; Language -&gt; Bool
&gt; :: Language -&gt; Language -&gt; Bool
$c&gt; :: Language -&gt; Language -&gt; Bool
&lt;= :: Language -&gt; Language -&gt; Bool
$c&lt;= :: Language -&gt; Language -&gt; Bool
&lt; :: Language -&gt; Language -&gt; Bool
$c&lt; :: Language -&gt; Language -&gt; Bool
compare :: Language -&gt; Language -&gt; Ordering
$ccompare :: Language -&gt; Language -&gt; Ordering
$cp1Ord :: Eq Language
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="%24cUnknownLanguage"><span id="%24cHaskellAllDisabled"><span id="%24cHaskell2010"><span id="%24cHaskell98"><span id="%24tLanguage"><span id="local-6989586621679386964"><span id="local-6989586621679386966"><span id="local-6989586621679386968"><span id="local-6989586621679386970"><span id="local-6989586621679386972"><span id="local-6989586621679386974"><span id="local-6989586621679386976"><span id="local-6989586621679386978"><span id="local-6989586621679386980"><span id="local-6989586621679386982"><span id="local-6989586621679386984"><span id="local-6989586621679386986"><span id="local-6989586621679386988"><span id="local-6989586621679386990"><span class="annot"><span class="annottext">Typeable Language
DataType
Constr
Typeable Language
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; Language -&gt; c Language)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Language)
-&gt; (Language -&gt; Constr)
-&gt; (Language -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Language))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Language))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; Language -&gt; Language)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language)
-&gt; Data Language
Language -&gt; DataType
Language -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; Language -&gt; Language
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Language -&gt; c Language
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Language
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Language
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Language -&gt; c Language
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Language)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Language)
$cUnknownLanguage :: Constr
$cHaskellAllDisabled :: Constr
$cHaskell2010 :: Constr
$cHaskell98 :: Constr
$tLanguage :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
gmapMp :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
gmapM :: (forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d) -&gt; Language -&gt; m Language
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; u
$cgmapQi :: forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; Language -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; Language -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Language -&gt; Language
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; Language -&gt; Language
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Language)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c Language)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Language)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c Language)
dataTypeOf :: Language -&gt; DataType
$cdataTypeOf :: Language -&gt; DataType
toConstr :: Language -&gt; Constr
$ctoConstr :: Language -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Language
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c Language
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Language -&gt; c Language
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; Language -&gt; c Language
$cp1Data :: Typeable Language
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">)</span><span>
</span><span id="line-104"></span><span>
</span><span id="line-105"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#knownLanguages"><span class="hs-identifier hs-type">knownLanguages</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier hs-type">Language</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-106"></span><span id="knownLanguages"><span class="annot"><span class="annottext">knownLanguages :: [Language]
</span><a href="Language.Haskell.Exts.Extension.html#knownLanguages"><span class="hs-identifier hs-var hs-var">knownLanguages</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Language
</span><a href="Language.Haskell.Exts.Extension.html#Haskell98"><span class="hs-identifier hs-var">Haskell98</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Language
</span><a href="Language.Haskell.Exts.Extension.html#Haskell2010"><span class="hs-identifier hs-var">Haskell2010</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-107"></span><span>
</span><span id="line-108"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyLanguage"><span class="hs-identifier hs-type">classifyLanguage</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier hs-type">Language</span></a></span><span>
</span><span id="line-109"></span><span id="classifyLanguage"><span class="annot"><span class="annottext">classifyLanguage :: String -&gt; Language
</span><a href="Language.Haskell.Exts.Extension.html#classifyLanguage"><span class="hs-identifier hs-var hs-var">classifyLanguage</span></a></span></span><span> </span><span id="local-6989586621679386957"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386957"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Language -&gt; Maybe Language -&gt; Language
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Language
</span><a href="Language.Haskell.Exts.Extension.html#UnknownLanguage"><span class="hs-identifier hs-var">UnknownLanguage</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386957"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe Language -&gt; Language) -&gt; Maybe Language -&gt; Language
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; [(String, Language)] -&gt; Maybe Language
forall a b. Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
</span><span class="hs-identifier hs-var">lookup</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386957"><span class="hs-identifier hs-var">str</span></a></span><span> </span><span class="annot"><span class="annottext">[(String, Language)]
</span><a href="#local-6989586621679386955"><span class="hs-identifier hs-var">langTable</span></a></span><span>
</span><span id="line-110"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-111"></span><span>    </span><span id="local-6989586621679386955"><span class="annot"><span class="annottext">langTable :: [(String, Language)]
</span><a href="#local-6989586621679386955"><span class="hs-identifier hs-var hs-var">langTable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Language -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386953"><span class="hs-identifier hs-var">lang</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386953"><span class="hs-identifier hs-var">lang</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-112"></span><span>                </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679386953"><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386953"><span class="hs-identifier hs-var">lang</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">[Language]
</span><a href="Language.Haskell.Exts.Extension.html#knownLanguages"><span class="hs-identifier hs-var">knownLanguages</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-113"></span><span>
</span><span id="line-114"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyLanguage"><span class="hs-identifier hs-type">prettyLanguage</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier hs-type">Language</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-115"></span><span id="prettyLanguage"><span class="annot"><span class="annottext">prettyLanguage :: Language -&gt; String
</span><a href="Language.Haskell.Exts.Extension.html#prettyLanguage"><span class="hs-identifier hs-var hs-var">prettyLanguage</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnknownLanguage"><span class="hs-identifier hs-type">UnknownLanguage</span></a></span><span> </span><span id="local-6989586621679386952"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386952"><span class="hs-identifier hs-var">name</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386952"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-116"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyLanguage"><span class="hs-identifier hs-var">prettyLanguage</span></a></span><span> </span><span id="local-6989586621679386951"><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386951"><span class="hs-identifier hs-var">lang</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Language -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386951"><span class="hs-identifier hs-var">lang</span></a></span><span>
</span><span id="line-117"></span><span>
</span><span id="line-118"></span><span class="hs-comment">-- | This represents language extensions beyond a base 'Language' definition</span><span>
</span><span id="line-119"></span><span class="hs-comment">-- (such as 'Haskell98') that are supported by some implementations, usually</span><span>
</span><span id="line-120"></span><span class="hs-comment">-- in some special mode.</span><span>
</span><span id="line-121"></span><span>
</span><span id="line-122"></span><span class="hs-keyword">data</span><span> </span><span id="Extension"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-var">Extension</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-123"></span><span>  </span><span class="hs-comment">-- | Enable a known extension</span><span>
</span><span id="line-124"></span><span>    </span><span id="EnableExtension"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span>
</span><span id="line-125"></span><span>
</span><span id="line-126"></span><span>  </span><span class="hs-comment">-- | Disable a known extension</span><span>
</span><span id="line-127"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DisableExtension"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-var">DisableExtension</span></a></span></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span>
</span><span id="line-128"></span><span>
</span><span id="line-129"></span><span>  </span><span class="hs-comment">-- | An unknown extension, identified by the name of its @LANGUAGE@</span><span>
</span><span id="line-130"></span><span>  </span><span class="hs-comment">-- pragma.</span><span>
</span><span id="line-131"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnknownExtension"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnknownExtension"><span class="hs-identifier hs-var">UnknownExtension</span></a></span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-132"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679386942"><span id="local-6989586621679386944"><span id="local-6989586621679386946"><span class="annot"><span class="annottext">Int -&gt; Extension -&gt; ShowS
[Extension] -&gt; ShowS
Extension -&gt; String
(Int -&gt; Extension -&gt; ShowS)
-&gt; (Extension -&gt; String)
-&gt; ([Extension] -&gt; ShowS)
-&gt; Show Extension
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [Extension] -&gt; ShowS
$cshowList :: [Extension] -&gt; ShowS
show :: Extension -&gt; String
$cshow :: Extension -&gt; String
showsPrec :: Int -&gt; Extension -&gt; ShowS
$cshowsPrec :: Int -&gt; Extension -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386934"><span id="local-6989586621679386936"><span id="local-6989586621679386938"><span id="local-6989586621679386940"><span class="annot"><span class="annottext">ReadPrec [Extension]
ReadPrec Extension
Int -&gt; ReadS Extension
ReadS [Extension]
(Int -&gt; ReadS Extension)
-&gt; ReadS [Extension]
-&gt; ReadPrec Extension
-&gt; ReadPrec [Extension]
-&gt; Read Extension
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
readListPrec :: ReadPrec [Extension]
$creadListPrec :: ReadPrec [Extension]
readPrec :: ReadPrec Extension
$creadPrec :: ReadPrec Extension
readList :: ReadS [Extension]
$creadList :: ReadS [Extension]
readsPrec :: Int -&gt; ReadS Extension
$creadsPrec :: Int -&gt; ReadS Extension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386930"><span id="local-6989586621679386932"><span class="annot"><span class="annottext">Extension -&gt; Extension -&gt; Bool
(Extension -&gt; Extension -&gt; Bool)
-&gt; (Extension -&gt; Extension -&gt; Bool) -&gt; Eq Extension
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: Extension -&gt; Extension -&gt; Bool
$c/= :: Extension -&gt; Extension -&gt; Bool
== :: Extension -&gt; Extension -&gt; Bool
$c== :: Extension -&gt; Extension -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386915"><span id="local-6989586621679386917"><span id="local-6989586621679386919"><span id="local-6989586621679386921"><span id="local-6989586621679386923"><span id="local-6989586621679386925"><span id="local-6989586621679386927"><span class="annot"><span class="annottext">Eq Extension
Eq Extension
-&gt; (Extension -&gt; Extension -&gt; Ordering)
-&gt; (Extension -&gt; Extension -&gt; Bool)
-&gt; (Extension -&gt; Extension -&gt; Bool)
-&gt; (Extension -&gt; Extension -&gt; Bool)
-&gt; (Extension -&gt; Extension -&gt; Bool)
-&gt; (Extension -&gt; Extension -&gt; Extension)
-&gt; (Extension -&gt; Extension -&gt; Extension)
-&gt; Ord Extension
Extension -&gt; Extension -&gt; Bool
Extension -&gt; Extension -&gt; Ordering
Extension -&gt; Extension -&gt; Extension
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: Extension -&gt; Extension -&gt; Extension
$cmin :: Extension -&gt; Extension -&gt; Extension
max :: Extension -&gt; Extension -&gt; Extension
$cmax :: Extension -&gt; Extension -&gt; Extension
&gt;= :: Extension -&gt; Extension -&gt; Bool
$c&gt;= :: Extension -&gt; Extension -&gt; Bool
&gt; :: Extension -&gt; Extension -&gt; Bool
$c&gt; :: Extension -&gt; Extension -&gt; Bool
&lt;= :: Extension -&gt; Extension -&gt; Bool
$c&lt;= :: Extension -&gt; Extension -&gt; Bool
&lt; :: Extension -&gt; Extension -&gt; Bool
$c&lt; :: Extension -&gt; Extension -&gt; Bool
compare :: Extension -&gt; Extension -&gt; Ordering
$ccompare :: Extension -&gt; Extension -&gt; Ordering
$cp1Ord :: Eq Extension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-keyword">data</span><span> </span><span id="KnownExtension"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-var">KnownExtension</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-136"></span><span>
</span><span id="line-137"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.4] Allow overlapping class instances,</span><span>
</span><span id="line-138"></span><span>  </span><span class="hs-comment">-- provided there is a unique most specific instance for each use.</span><span>
</span><span id="line-139"></span><span>    </span><span id="OverlappingInstances"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#OverlappingInstances"><span class="hs-identifier hs-var">OverlappingInstances</span></a></span></span><span>
</span><span id="line-140"></span><span>
</span><span id="line-141"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.3] Ignore structural rules guaranteeing the</span><span>
</span><span id="line-142"></span><span>  </span><span class="hs-comment">-- termination of class instance resolution.  Termination is</span><span>
</span><span id="line-143"></span><span>  </span><span class="hs-comment">-- guaranteed by a fixed-depth recursion stack, and compilation</span><span>
</span><span id="line-144"></span><span>  </span><span class="hs-comment">-- may fail if this depth is exceeded.</span><span>
</span><span id="line-145"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UndecidableInstances"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UndecidableInstances"><span class="hs-identifier hs-var">UndecidableInstances</span></a></span></span><span>
</span><span id="line-146"></span><span>
</span><span id="line-147"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.4] Implies 'OverlappingInstances'.  Allow the</span><span>
</span><span id="line-148"></span><span>  </span><span class="hs-comment">-- implementation to choose an instance even when it is possible</span><span>
</span><span id="line-149"></span><span>  </span><span class="hs-comment">-- that further instantiation of types will lead to a more specific</span><span>
</span><span id="line-150"></span><span>  </span><span class="hs-comment">-- instance being applicable.</span><span>
</span><span id="line-151"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="IncoherentInstances"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#IncoherentInstances"><span class="hs-identifier hs-var">IncoherentInstances</span></a></span></span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.5] Allow type signatures in instances.</span><span>
</span><span id="line-154"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InstanceSigs"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#InstanceSigs"><span class="hs-identifier hs-var">InstanceSigs</span></a></span></span><span>
</span><span id="line-155"></span><span>
</span><span id="line-156"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.8] Deprecated in GHC.  Allows recursive</span><span>
</span><span id="line-157"></span><span>  </span><span class="hs-comment">-- bindings in @do@ blocks, using the @rec@ keyword.</span><span>
</span><span id="line-158"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DoRec"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DoRec"><span class="hs-identifier hs-var">DoRec</span></a></span></span><span>
</span><span id="line-159"></span><span>
</span><span id="line-160"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.8.2] Allows recursive bindings using @mdo@, a</span><span>
</span><span id="line-161"></span><span>  </span><span class="hs-comment">-- variant of @do@, and @rec@.</span><span>
</span><span id="line-162"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecursiveDo"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RecursiveDo"><span class="hs-identifier hs-var">RecursiveDo</span></a></span></span><span>
</span><span id="line-163"></span><span>
</span><span id="line-164"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.9] Provide syntax for writing list</span><span>
</span><span id="line-165"></span><span>  </span><span class="hs-comment">-- comprehensions which iterate over several lists together, like</span><span>
</span><span id="line-166"></span><span>  </span><span class="hs-comment">-- the 'zipWith' family of functions.</span><span>
</span><span id="line-167"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParallelListComp"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ParallelListComp"><span class="hs-identifier hs-var">ParallelListComp</span></a></span></span><span>
</span><span id="line-168"></span><span>
</span><span id="line-169"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.1.1] Allow multiple parameters in a type class.</span><span>
</span><span id="line-170"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MultiParamTypeClasses"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MultiParamTypeClasses"><span class="hs-identifier hs-var">MultiParamTypeClasses</span></a></span></span><span>
</span><span id="line-171"></span><span>
</span><span id="line-172"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.17] Enable the dreaded monomorphism restriction.</span><span>
</span><span id="line-173"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MonomorphismRestriction"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MonomorphismRestriction"><span class="hs-identifier hs-var">MonomorphismRestriction</span></a></span></span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.2] Allow a specification attached to a</span><span>
</span><span id="line-176"></span><span>  </span><span class="hs-comment">-- multi-parameter type class which indicates that some parameters</span><span>
</span><span id="line-177"></span><span>  </span><span class="hs-comment">-- are entirely determined by others. The implementation will check</span><span>
</span><span id="line-178"></span><span>  </span><span class="hs-comment">-- that this property holds for the declared instances, and will use</span><span>
</span><span id="line-179"></span><span>  </span><span class="hs-comment">-- this property to reduce ambiguity in instance resolution.</span><span>
</span><span id="line-180"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FunctionalDependencies"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#FunctionalDependencies"><span class="hs-identifier hs-var">FunctionalDependencies</span></a></span></span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.5] Like 'RankNTypes' but does not allow a</span><span>
</span><span id="line-183"></span><span>  </span><span class="hs-comment">-- higher-rank type to itself appear on the left of a function</span><span>
</span><span id="line-184"></span><span>  </span><span class="hs-comment">-- arrow.</span><span>
</span><span id="line-185"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Rank2Types"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Rank2Types"><span class="hs-identifier hs-var">Rank2Types</span></a></span></span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.5] Allow a universally-quantified type to occur on</span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-comment">-- the left of a function arrow.</span><span>
</span><span id="line-189"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RankNTypes"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RankNTypes"><span class="hs-identifier hs-var">RankNTypes</span></a></span></span><span>
</span><span id="line-190"></span><span>
</span><span id="line-191"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.5] Allow data constructors to have polymorphic</span><span>
</span><span id="line-192"></span><span>  </span><span class="hs-comment">-- arguments.  Unlike 'RankNTypes', does not allow this for ordinary</span><span>
</span><span id="line-193"></span><span>  </span><span class="hs-comment">-- functions.</span><span>
</span><span id="line-194"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PolymorphicComponents"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PolymorphicComponents"><span class="hs-identifier hs-var">PolymorphicComponents</span></a></span></span><span>
</span><span id="line-195"></span><span>
</span><span id="line-196"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.4.4] Allow existentially-quantified data constructors.</span><span>
</span><span id="line-197"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExistentialQuantification"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ExistentialQuantification"><span class="hs-identifier hs-var">ExistentialQuantification</span></a></span></span><span>
</span><span id="line-198"></span><span>
</span><span id="line-199"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.7] Cause a type variable in a signature, which has an</span><span>
</span><span id="line-200"></span><span>  </span><span class="hs-comment">-- explicit @forall@ quantifier, to scope over the definition of the</span><span>
</span><span id="line-201"></span><span>  </span><span class="hs-comment">-- accompanying value declaration.</span><span>
</span><span id="line-202"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ScopedTypeVariables"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ScopedTypeVariables"><span class="hs-identifier hs-var">ScopedTypeVariables</span></a></span></span><span>
</span><span id="line-203"></span><span>
</span><span id="line-204"></span><span>  </span><span class="hs-comment">-- | Deprecated, use 'ScopedTypeVariables' instead.</span><span>
</span><span id="line-205"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatternSignatures"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PatternSignatures"><span class="hs-identifier hs-var">PatternSignatures</span></a></span></span><span>
</span><span id="line-206"></span><span>
</span><span id="line-207"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.3] Enable implicit function parameters with dynamic</span><span>
</span><span id="line-208"></span><span>  </span><span class="hs-comment">-- scope.</span><span>
</span><span id="line-209"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitParams"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ImplicitParams"><span class="hs-identifier hs-var">ImplicitParams</span></a></span></span><span>
</span><span id="line-210"></span><span>
</span><span id="line-211"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.2] Relax some restrictions on the form of the context</span><span>
</span><span id="line-212"></span><span>  </span><span class="hs-comment">-- of a type signature.</span><span>
</span><span id="line-213"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FlexibleContexts"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#FlexibleContexts"><span class="hs-identifier hs-var">FlexibleContexts</span></a></span></span><span>
</span><span id="line-214"></span><span>
</span><span id="line-215"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.2] Relax some restrictions on the form of the</span><span>
</span><span id="line-216"></span><span>  </span><span class="hs-comment">-- context of an instance declaration.</span><span>
</span><span id="line-217"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="FlexibleInstances"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#FlexibleInstances"><span class="hs-identifier hs-var">FlexibleInstances</span></a></span></span><span>
</span><span id="line-218"></span><span>
</span><span id="line-219"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.4.1] Allow data type declarations with no constructors.</span><span>
</span><span id="line-220"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="EmptyDataDecls"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#EmptyDataDecls"><span class="hs-identifier hs-var">EmptyDataDecls</span></a></span></span><span>
</span><span id="line-221"></span><span>
</span><span id="line-222"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 4.10.3] Run the C preprocessor on Haskell source code.</span><span>
</span><span id="line-223"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CPP"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#CPP"><span class="hs-identifier hs-var">CPP</span></a></span></span><span>
</span><span id="line-224"></span><span>
</span><span id="line-225"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.4] Allow an explicit kind signature giving the kind of</span><span>
</span><span id="line-226"></span><span>  </span><span class="hs-comment">-- types over which a type variable ranges.</span><span>
</span><span id="line-227"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="KindSignatures"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KindSignatures"><span class="hs-identifier hs-var">KindSignatures</span></a></span></span><span>
</span><span id="line-228"></span><span>
</span><span id="line-229"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.11] Enable a form of pattern which forces evaluation</span><span>
</span><span id="line-230"></span><span>  </span><span class="hs-comment">-- before an attempted match, and a form of strict @let@/@where@</span><span>
</span><span id="line-231"></span><span>  </span><span class="hs-comment">-- binding.</span><span>
</span><span id="line-232"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BangPatterns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#BangPatterns"><span class="hs-identifier hs-var">BangPatterns</span></a></span></span><span>
</span><span id="line-233"></span><span>
</span><span id="line-234"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.3.1] Allow type synonyms in instance heads.</span><span>
</span><span id="line-235"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeSynonymInstances"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeSynonymInstances"><span class="hs-identifier hs-var">TypeSynonymInstances</span></a></span></span><span>
</span><span id="line-236"></span><span>
</span><span id="line-237"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.9] Enable Template Haskell, a system for compile-time</span><span>
</span><span id="line-238"></span><span>  </span><span class="hs-comment">-- metaprogramming.</span><span>
</span><span id="line-239"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TemplateHaskell"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TemplateHaskell"><span class="hs-identifier hs-var">TemplateHaskell</span></a></span></span><span>
</span><span id="line-240"></span><span>
</span><span id="line-241"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 8] Enable the Foreign Function Interface.  In GHC,</span><span>
</span><span id="line-242"></span><span>  </span><span class="hs-comment">-- implements the standard Haskell 98 Foreign Function Interface</span><span>
</span><span id="line-243"></span><span>  </span><span class="hs-comment">-- Addendum, plus some GHC-specific extensions.</span><span>
</span><span id="line-244"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ForeignFunctionInterface"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ForeignFunctionInterface"><span class="hs-identifier hs-var">ForeignFunctionInterface</span></a></span></span><span>
</span><span id="line-245"></span><span>
</span><span id="line-246"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.10] Enable arrow notation.</span><span>
</span><span id="line-247"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Arrows"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Arrows"><span class="hs-identifier hs-var">Arrows</span></a></span></span><span>
</span><span id="line-248"></span><span>
</span><span id="line-249"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.16] Enable generic type classes, with default instances</span><span>
</span><span id="line-250"></span><span>  </span><span class="hs-comment">-- defined in terms of the algebraic structure of a type.</span><span>
</span><span id="line-251"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Generics"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Generics"><span class="hs-identifier hs-var">Generics</span></a></span></span><span>
</span><span id="line-252"></span><span>
</span><span id="line-253"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.11] Enable the implicit importing of the module</span><span>
</span><span id="line-254"></span><span>  </span><span class="hs-comment">-- @Prelude@.  When disabled, when desugaring certain built-in syntax</span><span>
</span><span id="line-255"></span><span>  </span><span class="hs-comment">-- into ordinary identifiers, use whatever is in scope rather than the</span><span>
</span><span id="line-256"></span><span>  </span><span class="hs-comment">-- @Prelude@ -- version.</span><span>
</span><span id="line-257"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImplicitPrelude"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ImplicitPrelude"><span class="hs-identifier hs-var">ImplicitPrelude</span></a></span></span><span>
</span><span id="line-258"></span><span>
</span><span id="line-259"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.15] Enable syntax for implicitly binding local names</span><span>
</span><span id="line-260"></span><span>  </span><span class="hs-comment">-- corresponding to the field names of a record.  Puns bind specific</span><span>
</span><span id="line-261"></span><span>  </span><span class="hs-comment">-- names, unlike 'RecordWildCards'.</span><span>
</span><span id="line-262"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NamedFieldPuns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#NamedFieldPuns"><span class="hs-identifier hs-var">NamedFieldPuns</span></a></span></span><span>
</span><span id="line-263"></span><span>
</span><span id="line-264"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.5] Enable a form of guard which matches a pattern and</span><span>
</span><span id="line-265"></span><span>  </span><span class="hs-comment">-- binds variables.</span><span>
</span><span id="line-266"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatternGuards"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PatternGuards"><span class="hs-identifier hs-var">PatternGuards</span></a></span></span><span>
</span><span id="line-267"></span><span>
</span><span id="line-268"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.5.4] Allow a type declared with @newtype@ to use</span><span>
</span><span id="line-269"></span><span>  </span><span class="hs-comment">-- @deriving@ for any class with an instance for the underlying type.</span><span>
</span><span id="line-270"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GeneralizedNewtypeDeriving"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#GeneralizedNewtypeDeriving"><span class="hs-identifier hs-var">GeneralizedNewtypeDeriving</span></a></span></span><span>
</span><span id="line-271"></span><span>
</span><span id="line-272"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 9.6.10] Allow use of any typeclass in deriving clauses.</span><span>
</span><span id="line-273"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveAnyClass"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveAnyClass"><span class="hs-identifier hs-var">DeriveAnyClass</span></a></span></span><span>
</span><span id="line-274"></span><span>
</span><span id="line-275"></span><span>  </span><span class="hs-comment">-- | [Hugs &amp;#xa7; 7.1] Enable the \&quot;Trex\&quot; extensible records system.</span><span>
</span><span id="line-276"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExtensibleRecords"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ExtensibleRecords"><span class="hs-identifier hs-var">ExtensibleRecords</span></a></span></span><span>
</span><span id="line-277"></span><span>
</span><span id="line-278"></span><span>  </span><span class="hs-comment">-- | [Hugs &amp;#xa7; 7.2] Enable type synonyms which are transparent in</span><span>
</span><span id="line-279"></span><span>  </span><span class="hs-comment">-- some definitions and opaque elsewhere, as a way of implementing</span><span>
</span><span id="line-280"></span><span>  </span><span class="hs-comment">-- abstract datatypes.</span><span>
</span><span id="line-281"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RestrictedTypeSynonyms"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RestrictedTypeSynonyms"><span class="hs-identifier hs-var">RestrictedTypeSynonyms</span></a></span></span><span>
</span><span id="line-282"></span><span>
</span><span id="line-283"></span><span>  </span><span class="hs-comment">-- | [Hugs &amp;#xa7; 7.3] Enable an alternate syntax for string literals,</span><span>
</span><span id="line-284"></span><span>  </span><span class="hs-comment">-- with string templating.</span><span>
</span><span id="line-285"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="HereDocuments"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#HereDocuments"><span class="hs-identifier hs-var">HereDocuments</span></a></span></span><span>
</span><span id="line-286"></span><span>
</span><span id="line-287"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.2] Allow the character @#@ as a postfix modifier on</span><span>
</span><span id="line-288"></span><span>  </span><span class="hs-comment">-- identifiers.  Also enables literal syntax for unboxed values.</span><span>
</span><span id="line-289"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MagicHash"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MagicHash"><span class="hs-identifier hs-var">MagicHash</span></a></span></span><span>
</span><span id="line-290"></span><span>
</span><span id="line-291"></span><span>  </span><span class="hs-comment">-- | Binary integer literals</span><span>
</span><span id="line-292"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BinaryLiterals"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#BinaryLiterals"><span class="hs-identifier hs-var">BinaryLiterals</span></a></span></span><span>
</span><span id="line-293"></span><span>
</span><span id="line-294"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.7] Allow data types and type synonyms which are</span><span>
</span><span id="line-295"></span><span>  </span><span class="hs-comment">-- indexed by types, i.e. ad-hoc polymorphism for types.</span><span>
</span><span id="line-296"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeFamilies"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeFamilies"><span class="hs-identifier hs-var">TypeFamilies</span></a></span></span><span>
</span><span id="line-297"></span><span>
</span><span id="line-298"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.5.2] Allow a standalone declaration which invokes the</span><span>
</span><span id="line-299"></span><span>  </span><span class="hs-comment">-- type class @deriving@ mechanism.</span><span>
</span><span id="line-300"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StandaloneDeriving"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#StandaloneDeriving"><span class="hs-identifier hs-var">StandaloneDeriving</span></a></span></span><span>
</span><span id="line-301"></span><span>
</span><span id="line-302"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.1] Allow certain Unicode characters to stand for</span><span>
</span><span id="line-303"></span><span>  </span><span class="hs-comment">-- certain ASCII character sequences, e.g. keywords and punctuation.</span><span>
</span><span id="line-304"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnicodeSyntax"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnicodeSyntax"><span class="hs-identifier hs-var">UnicodeSyntax</span></a></span></span><span>
</span><span id="line-305"></span><span>
</span><span id="line-306"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 8.1.1] Allow the use of unboxed types as foreign types,</span><span>
</span><span id="line-307"></span><span>  </span><span class="hs-comment">-- e.g. in @foreign import@ and @foreign export@.</span><span>
</span><span id="line-308"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnliftedFFITypes"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnliftedFFITypes"><span class="hs-identifier hs-var">UnliftedFFITypes</span></a></span></span><span>
</span><span id="line-309"></span><span>
</span><span id="line-310"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.4.3] Defer validity checking of types until after</span><span>
</span><span id="line-311"></span><span>  </span><span class="hs-comment">-- expanding type synonyms, relaxing the constraints on how synonyms</span><span>
</span><span id="line-312"></span><span>  </span><span class="hs-comment">-- may be used.</span><span>
</span><span id="line-313"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LiberalTypeSynonyms"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#LiberalTypeSynonyms"><span class="hs-identifier hs-var">LiberalTypeSynonyms</span></a></span></span><span>
</span><span id="line-314"></span><span>
</span><span id="line-315"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.4.2] Allow the name of a type constructor, type class,</span><span>
</span><span id="line-316"></span><span>  </span><span class="hs-comment">-- or type variable to be an infix operator.</span><span>
</span><span id="line-317"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeOperators"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeOperators"><span class="hs-identifier hs-var">TypeOperators</span></a></span></span><span>
</span><span id="line-318"></span><span>
</span><span id="line-319"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.26.5] Parallel arrays for Data Parallel Haskell.</span><span>
</span><span id="line-320"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ParallelArrays"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ParallelArrays"><span class="hs-identifier hs-var">ParallelArrays</span></a></span></span><span>
</span><span id="line-321"></span><span>
</span><span id="line-322"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.16] Enable syntax for implicitly binding local names</span><span>
</span><span id="line-323"></span><span>  </span><span class="hs-comment">-- corresponding to the field names of a record.  A wildcard binds</span><span>
</span><span id="line-324"></span><span>  </span><span class="hs-comment">-- all unmentioned names, unlike 'NamedFieldPuns'.</span><span>
</span><span id="line-325"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordWildCards"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RecordWildCards"><span class="hs-identifier hs-var">RecordWildCards</span></a></span></span><span>
</span><span id="line-326"></span><span>
</span><span id="line-327"></span><span>  </span><span class="hs-comment">-- | Deprecated, use 'NamedFieldPuns' instead.</span><span>
</span><span id="line-328"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RecordPuns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RecordPuns"><span class="hs-identifier hs-var">RecordPuns</span></a></span></span><span>
</span><span id="line-329"></span><span>
</span><span id="line-330"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.14] Allow a record field name to be disambiguated</span><span>
</span><span id="line-331"></span><span>  </span><span class="hs-comment">-- by the type of the record it's in.</span><span>
</span><span id="line-332"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DisambiguateRecordFields"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DisambiguateRecordFields"><span class="hs-identifier hs-var">DisambiguateRecordFields</span></a></span></span><span>
</span><span id="line-333"></span><span>
</span><span id="line-334"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.4] Enable overloading of string literals using a</span><span>
</span><span id="line-335"></span><span>  </span><span class="hs-comment">-- type class, much like integer literals.</span><span>
</span><span id="line-336"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OverloadedStrings"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#OverloadedStrings"><span class="hs-identifier hs-var">OverloadedStrings</span></a></span></span><span>
</span><span id="line-337"></span><span>
</span><span id="line-338"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.4.6] Enable generalized algebraic data types, in</span><span>
</span><span id="line-339"></span><span>  </span><span class="hs-comment">-- which type variables may be instantiated on a per-constructor</span><span>
</span><span id="line-340"></span><span>  </span><span class="hs-comment">-- basis. Implies GADTSyntax.</span><span>
</span><span id="line-341"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GADTs"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#GADTs"><span class="hs-identifier hs-var">GADTs</span></a></span></span><span>
</span><span id="line-342"></span><span>
</span><span id="line-343"></span><span class="hs-comment">{- GADTSyntax (the extension name) not yet supported by HSE

  -- | Enable GADT syntax for declaring ordinary algebraic datatypes.
  | GADTSyntax

-}</span><span>
</span><span id="line-349"></span><span>
</span><span id="line-350"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.17.2] Make pattern bindings monomorphic.</span><span>
</span><span id="line-351"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MonoPatBinds"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MonoPatBinds"><span class="hs-identifier hs-var">MonoPatBinds</span></a></span></span><span>
</span><span id="line-352"></span><span>
</span><span id="line-353"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.8] Relax the requirements on mutually-recursive</span><span>
</span><span id="line-354"></span><span>  </span><span class="hs-comment">-- polymorphic functions.</span><span>
</span><span id="line-355"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RelaxedPolyRec"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RelaxedPolyRec"><span class="hs-identifier hs-var">RelaxedPolyRec</span></a></span></span><span>
</span><span id="line-356"></span><span>
</span><span id="line-357"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 2.4.5] Allow default instantiation of polymorphic</span><span>
</span><span id="line-358"></span><span>  </span><span class="hs-comment">-- types in more situations.</span><span>
</span><span id="line-359"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExtendedDefaultRules"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ExtendedDefaultRules"><span class="hs-identifier hs-var">ExtendedDefaultRules</span></a></span></span><span>
</span><span id="line-360"></span><span>
</span><span id="line-361"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.2.2] Enable unboxed tuples.</span><span>
</span><span id="line-362"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedTuples"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnboxedTuples"><span class="hs-identifier hs-var">UnboxedTuples</span></a></span></span><span>
</span><span id="line-363"></span><span>
</span><span id="line-364"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.5.3] Enable @deriving@ for classes</span><span>
</span><span id="line-365"></span><span>  </span><span class="hs-comment">-- @Data.Typeable.Typeable@ and @Data.Generics.Data@.</span><span>
</span><span id="line-366"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveDataTypeable"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveDataTypeable"><span class="hs-identifier hs-var">DeriveDataTypeable</span></a></span></span><span>
</span><span id="line-367"></span><span>
</span><span id="line-368"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.1.3] Allow a class method's type to place</span><span>
</span><span id="line-369"></span><span>  </span><span class="hs-comment">-- additional constraints on a class type variable.</span><span>
</span><span id="line-370"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConstrainedClassMethods"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ConstrainedClassMethods"><span class="hs-identifier hs-var">ConstrainedClassMethods</span></a></span></span><span>
</span><span id="line-371"></span><span>
</span><span id="line-372"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.18] Allow imports to be qualified by the package</span><span>
</span><span id="line-373"></span><span>  </span><span class="hs-comment">-- name the module is intended to be imported from, e.g.</span><span>
</span><span id="line-374"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-375"></span><span>  </span><span class="hs-comment">-- &gt; import &quot;network&quot; Network.Socket</span><span>
</span><span id="line-376"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PackageImports"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PackageImports"><span class="hs-identifier hs-var">PackageImports</span></a></span></span><span>
</span><span id="line-377"></span><span>
</span><span id="line-378"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="LambdaCase"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#LambdaCase"><span class="hs-identifier hs-var">LambdaCase</span></a></span></span><span>
</span><span id="line-379"></span><span>
</span><span id="line-380"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.20] Allow case expressions with no alternatives.</span><span>
</span><span id="line-381"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="EmptyCase"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#EmptyCase"><span class="hs-identifier hs-var">EmptyCase</span></a></span></span><span>
</span><span id="line-382"></span><span>
</span><span id="line-383"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.8.6] Deprecated in GHC 6.12 and will be removed in</span><span>
</span><span id="line-384"></span><span>  </span><span class="hs-comment">-- GHC 7.  Allow a type variable to be instantiated at a</span><span>
</span><span id="line-385"></span><span>  </span><span class="hs-comment">-- polymorphic type.</span><span>
</span><span id="line-386"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ImpredicativeTypes"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ImpredicativeTypes"><span class="hs-identifier hs-var">ImpredicativeTypes</span></a></span></span><span>
</span><span id="line-387"></span><span>
</span><span id="line-388"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.3] Change the syntax for qualified infix</span><span>
</span><span id="line-389"></span><span>  </span><span class="hs-comment">-- operators.</span><span>
</span><span id="line-390"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NewQualifiedOperators"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#NewQualifiedOperators"><span class="hs-identifier hs-var">NewQualifiedOperators</span></a></span></span><span>
</span><span id="line-391"></span><span>
</span><span id="line-392"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.12] Relax the interpretation of left operator</span><span>
</span><span id="line-393"></span><span>  </span><span class="hs-comment">-- sections to allow unary postfix operators.</span><span>
</span><span id="line-394"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PostfixOperators"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PostfixOperators"><span class="hs-identifier hs-var">PostfixOperators</span></a></span></span><span>
</span><span id="line-395"></span><span>
</span><span id="line-396"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.9.5] Enable quasi-quotation, a mechanism for defining</span><span>
</span><span id="line-397"></span><span>  </span><span class="hs-comment">-- new concrete syntax for expressions and patterns.</span><span>
</span><span id="line-398"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="QuasiQuotes"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#QuasiQuotes"><span class="hs-identifier hs-var">QuasiQuotes</span></a></span></span><span>
</span><span id="line-399"></span><span>
</span><span id="line-400"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.10] Enable generalized list comprehensions,</span><span>
</span><span id="line-401"></span><span>  </span><span class="hs-comment">-- supporting operations such as sorting and grouping.</span><span>
</span><span id="line-402"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TransformListComp"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TransformListComp"><span class="hs-identifier hs-var">TransformListComp</span></a></span></span><span>
</span><span id="line-403"></span><span>
</span><span id="line-404"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.6] Enable view patterns, which match a value by</span><span>
</span><span id="line-405"></span><span>  </span><span class="hs-comment">-- applying a function and matching on the result.</span><span>
</span><span id="line-406"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ViewPatterns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ViewPatterns"><span class="hs-identifier hs-var">ViewPatterns</span></a></span></span><span>
</span><span id="line-407"></span><span>
</span><span id="line-408"></span><span>  </span><span class="hs-comment">-- | Allow concrete XML syntax to be used in expressions and patterns,</span><span>
</span><span id="line-409"></span><span>  </span><span class="hs-comment">-- as per the Haskell Server Pages extension language:</span><span>
</span><span id="line-410"></span><span>  </span><span class="hs-comment">-- &lt;http://www.haskell.org/haskellwiki/HSP&gt;. The ideas behind it are</span><span>
</span><span id="line-411"></span><span>  </span><span class="hs-comment">-- discussed in the paper \&quot;Haskell Server Pages through Dynamic Loading\&quot;</span><span>
</span><span id="line-412"></span><span>  </span><span class="hs-comment">-- by Niklas Broberg, from Haskell Workshop '05.</span><span>
</span><span id="line-413"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="XmlSyntax"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#XmlSyntax"><span class="hs-identifier hs-var">XmlSyntax</span></a></span></span><span>
</span><span id="line-414"></span><span>
</span><span id="line-415"></span><span>  </span><span class="hs-comment">-- | Allow regular pattern matching over lists, as discussed in the</span><span>
</span><span id="line-416"></span><span>  </span><span class="hs-comment">-- paper \&quot;Regular Expression Patterns\&quot; by Niklas Broberg, Andreas Farre</span><span>
</span><span id="line-417"></span><span>  </span><span class="hs-comment">-- and Josef Svenningsson, from ICFP '04.</span><span>
</span><span id="line-418"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RegularPatterns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RegularPatterns"><span class="hs-identifier hs-var">RegularPatterns</span></a></span></span><span>
</span><span id="line-419"></span><span>
</span><span id="line-420"></span><span>  </span><span class="hs-comment">-- | Enables the use of tuple sections, e.g. @(, True)@ desugars into</span><span>
</span><span id="line-421"></span><span>  </span><span class="hs-comment">-- @\x -&gt; (x, True)@.</span><span>
</span><span id="line-422"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TupleSections"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TupleSections"><span class="hs-identifier hs-var">TupleSections</span></a></span></span><span>
</span><span id="line-423"></span><span>
</span><span id="line-424"></span><span>  </span><span class="hs-comment">-- | Allows GHC primops, written in C--, to be imported into a Haskell</span><span>
</span><span id="line-425"></span><span>  </span><span class="hs-comment">-- file.</span><span>
</span><span id="line-426"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="GHCForeignImportPrim"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#GHCForeignImportPrim"><span class="hs-identifier hs-var">GHCForeignImportPrim</span></a></span></span><span>
</span><span id="line-427"></span><span>
</span><span id="line-428"></span><span>  </span><span class="hs-comment">-- | Support for patterns of the form @n + k@, where @k@ is an</span><span>
</span><span id="line-429"></span><span>  </span><span class="hs-comment">-- integer literal.</span><span>
</span><span id="line-430"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NPlusKPatterns"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#NPlusKPatterns"><span class="hs-identifier hs-var">NPlusKPatterns</span></a></span></span><span>
</span><span id="line-431"></span><span>
</span><span id="line-432"></span><span>  </span><span class="hs-comment">-- | Improve the layout rule when @if@ expressions are used in a @do@</span><span>
</span><span id="line-433"></span><span>  </span><span class="hs-comment">-- block.</span><span>
</span><span id="line-434"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DoAndIfThenElse"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DoAndIfThenElse"><span class="hs-identifier hs-var">DoAndIfThenElse</span></a></span></span><span>
</span><span id="line-435"></span><span>
</span><span id="line-436"></span><span>  </span><span class="hs-comment">-- | Makes much of the Haskell sugar be desugared into calls to the</span><span>
</span><span id="line-437"></span><span>  </span><span class="hs-comment">-- function with a particular name that is in scope.</span><span>
</span><span id="line-438"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RebindableSyntax"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RebindableSyntax"><span class="hs-identifier hs-var">RebindableSyntax</span></a></span></span><span>
</span><span id="line-439"></span><span>
</span><span id="line-440"></span><span>  </span><span class="hs-comment">-- | Make @forall@ a keyword in types, which can be used to give the</span><span>
</span><span id="line-441"></span><span>  </span><span class="hs-comment">-- generalisation explicitly.</span><span>
</span><span id="line-442"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitForAll"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span></span><span>
</span><span id="line-443"></span><span>
</span><span id="line-444"></span><span>  </span><span class="hs-comment">-- | Allow contexts to be put on datatypes, e.g. the @Eq a@ in</span><span>
</span><span id="line-445"></span><span>  </span><span class="hs-comment">-- @data Eq a =&gt; Set a = NilSet | ConsSet a (Set a)@.</span><span>
</span><span id="line-446"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DatatypeContexts"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DatatypeContexts"><span class="hs-identifier hs-var">DatatypeContexts</span></a></span></span><span>
</span><span id="line-447"></span><span>
</span><span id="line-448"></span><span>  </span><span class="hs-comment">-- | Local (@let@ and @where@) bindings are monomorphic.</span><span>
</span><span id="line-449"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MonoLocalBinds"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MonoLocalBinds"><span class="hs-identifier hs-var">MonoLocalBinds</span></a></span></span><span>
</span><span id="line-450"></span><span>
</span><span id="line-451"></span><span>  </span><span class="hs-comment">-- | Enable @deriving@ for the @Data.Functor.Functor@ class.</span><span>
</span><span id="line-452"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveFunctor"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveFunctor"><span class="hs-identifier hs-var">DeriveFunctor</span></a></span></span><span>
</span><span id="line-453"></span><span>
</span><span id="line-454"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.5.3] Enable @deriving@ for the @Generic@ and @Generic1@ classes.</span><span>
</span><span id="line-455"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveGeneric"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveGeneric"><span class="hs-identifier hs-var">DeriveGeneric</span></a></span></span><span>
</span><span id="line-456"></span><span>
</span><span id="line-457"></span><span>  </span><span class="hs-comment">-- | Enable @deriving@ for the @Data.Traversable.Traversable@ class.</span><span>
</span><span id="line-458"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveTraversable"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveTraversable"><span class="hs-identifier hs-var">DeriveTraversable</span></a></span></span><span>
</span><span id="line-459"></span><span>
</span><span id="line-460"></span><span>  </span><span class="hs-comment">-- | Enable @deriving@ for the @Data.Foldable.Foldable@ class.</span><span>
</span><span id="line-461"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DeriveFoldable"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DeriveFoldable"><span class="hs-identifier hs-var">DeriveFoldable</span></a></span></span><span>
</span><span id="line-462"></span><span>
</span><span id="line-463"></span><span>  </span><span class="hs-comment">-- | Enable non-decreasing indentation for 'do' blocks.</span><span>
</span><span id="line-464"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NondecreasingIndentation"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#NondecreasingIndentation"><span class="hs-identifier hs-var">NondecreasingIndentation</span></a></span></span><span>
</span><span id="line-465"></span><span>
</span><span id="line-466"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 8.1.4] Enable interruptible FFI.</span><span>
</span><span id="line-467"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="InterruptibleFFI"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#InterruptibleFFI"><span class="hs-identifier hs-var">InterruptibleFFI</span></a></span></span><span>
</span><span id="line-468"></span><span>
</span><span id="line-469"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 8.1.5] Enable the 'capi' calling convention in the</span><span>
</span><span id="line-470"></span><span>  </span><span class="hs-comment">-- foreign function interface.</span><span>
</span><span id="line-471"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="CApiFFI"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#CApiFFI"><span class="hs-identifier hs-var">CApiFFI</span></a></span></span><span>
</span><span id="line-472"></span><span>
</span><span id="line-473"></span><span>  </span><span class="hs-comment">-- | GHCJS FFI extension with convenient import patterns,</span><span>
</span><span id="line-474"></span><span>  </span><span class="hs-comment">-- asynchronous FFI and a JSVal FFI type</span><span>
</span><span id="line-475"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="JavaScriptFFI"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#JavaScriptFFI"><span class="hs-identifier hs-var">JavaScriptFFI</span></a></span></span><span>
</span><span id="line-476"></span><span>
</span><span id="line-477"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.27] Enable explicit namespaces in import/export.</span><span>
</span><span id="line-478"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ExplicitNamespaces"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ExplicitNamespaces"><span class="hs-identifier hs-var">ExplicitNamespaces</span></a></span></span><span>
</span><span id="line-479"></span><span>
</span><span id="line-480"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DataKinds"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DataKinds"><span class="hs-identifier hs-var">DataKinds</span></a></span></span><span>
</span><span id="line-481"></span><span>
</span><span id="line-482"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PolyKinds"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PolyKinds"><span class="hs-identifier hs-var">PolyKinds</span></a></span></span><span>
</span><span id="line-483"></span><span>
</span><span id="line-484"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.16] Enable the multi-way if-expressions</span><span>
</span><span id="line-485"></span><span>  </span><span class="hs-comment">-- extension to accept conditional expressions with multiple branches.</span><span>
</span><span id="line-486"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="MultiWayIf"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#MultiWayIf"><span class="hs-identifier hs-var">MultiWayIf</span></a></span></span><span>
</span><span id="line-487"></span><span>
</span><span id="line-488"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.20.3] Allow imports to be qualified with a safe</span><span>
</span><span id="line-489"></span><span>  </span><span class="hs-comment">-- keyword that requires the imported module be trusted as according</span><span>
</span><span id="line-490"></span><span>  </span><span class="hs-comment">-- to the Safe Haskell definition of trust.</span><span>
</span><span id="line-491"></span><span>  </span><span class="hs-comment">--</span><span>
</span><span id="line-492"></span><span>  </span><span class="hs-comment">-- &gt; import safe Network.Socket</span><span>
</span><span id="line-493"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="SafeImports"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#SafeImports"><span class="hs-identifier hs-var">SafeImports</span></a></span></span><span>
</span><span id="line-494"></span><span>
</span><span id="line-495"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.20] Compile a module in the Safe, Safe Haskell</span><span>
</span><span id="line-496"></span><span>  </span><span class="hs-comment">-- mode -- a restricted form of the Haskell language to ensure</span><span>
</span><span id="line-497"></span><span>  </span><span class="hs-comment">-- type safety.</span><span>
</span><span id="line-498"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Safe"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Safe"><span class="hs-identifier hs-var">Safe</span></a></span></span><span>
</span><span id="line-499"></span><span>
</span><span id="line-500"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.20] Compile a module in the Trustworthy, Safe</span><span>
</span><span id="line-501"></span><span>  </span><span class="hs-comment">-- Haskell mode -- no restrictions apply but the module is marked</span><span>
</span><span id="line-502"></span><span>  </span><span class="hs-comment">-- as trusted as long as the package the module resides in is</span><span>
</span><span id="line-503"></span><span>  </span><span class="hs-comment">-- trusted.</span><span>
</span><span id="line-504"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Trustworthy"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Trustworthy"><span class="hs-identifier hs-var">Trustworthy</span></a></span></span><span>
</span><span id="line-505"></span><span>
</span><span id="line-506"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.6.1.4] Allow default signatures in class</span><span>
</span><span id="line-507"></span><span>  </span><span class="hs-comment">-- definitions. They apply to default methods implemented in this</span><span>
</span><span id="line-508"></span><span>  </span><span class="hs-comment">-- class.</span><span>
</span><span id="line-509"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DefaultSignatures"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DefaultSignatures"><span class="hs-identifier hs-var">DefaultSignatures</span></a></span></span><span>
</span><span id="line-510"></span><span>
</span><span id="line-511"></span><span>
</span><span id="line-512"></span><span class="hs-comment">-- ConstraintKinds not generally supported by HSE. This flag makes RCategory2.hs</span><span>
</span><span id="line-513"></span><span class="hs-comment">-- pass testing though.</span><span>
</span><span id="line-514"></span><span>
</span><span id="line-515"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.40] Allow type class/implicit parameter/equality</span><span>
</span><span id="line-516"></span><span>  </span><span class="hs-comment">-- constraints to be used as types with the special kind Constraint.</span><span>
</span><span id="line-517"></span><span>  </span><span class="hs-comment">-- Also generalise the (ctxt =&gt; ty) syntax so that any type of kind</span><span>
</span><span id="line-518"></span><span>  </span><span class="hs-comment">-- Constraint can occur before the arrow.</span><span>
</span><span id="line-519"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="ConstraintKinds"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ConstraintKinds"><span class="hs-identifier hs-var">ConstraintKinds</span></a></span></span><span>
</span><span id="line-520"></span><span>
</span><span id="line-521"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.25.3] Allow role annotations.</span><span>
</span><span id="line-522"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="RoleAnnotations"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#RoleAnnotations"><span class="hs-identifier hs-var">RoleAnnotations</span></a></span></span><span>
</span><span id="line-523"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.3.8] Enable giving names to parametrized pattern</span><span>
</span><span id="line-524"></span><span>  </span><span class="hs-comment">-- schemes</span><span>
</span><span id="line-525"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PatternSynonyms"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PatternSynonyms"><span class="hs-identifier hs-var">PatternSynonyms</span></a></span></span><span>
</span><span id="line-526"></span><span>
</span><span id="line-527"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.15] Allow partial specified type signatures.</span><span>
</span><span id="line-528"></span><span>  </span><span class="hs-comment">-- Note that this extension does not affect parsing. It only affects whether the</span><span>
</span><span id="line-529"></span><span>  </span><span class="hs-comment">-- program is able to be run with partial signatures.</span><span>
</span><span id="line-530"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="PartialTypeSignatures"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#PartialTypeSignatures"><span class="hs-identifier hs-var">PartialTypeSignatures</span></a></span></span><span>
</span><span id="line-531"></span><span>
</span><span id="line-532"></span><span>  </span><span class="hs-comment">-- | [GHC &amp;#xa7; 7.15.1.2] This extension treats type variables which</span><span>
</span><span id="line-533"></span><span>  </span><span class="hs-comment">-- start with an underscore as wildcards. For example, `foo :: _x` is</span><span>
</span><span id="line-534"></span><span>  </span><span class="hs-comment">-- equivalent to `foo :: _`.</span><span>
</span><span id="line-535"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="NamedWildCards"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#NamedWildCards"><span class="hs-identifier hs-var">NamedWildCards</span></a></span></span><span>
</span><span id="line-536"></span><span>
</span><span id="line-537"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeApplications"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeApplications"><span class="hs-identifier hs-var">TypeApplications</span></a></span></span><span>
</span><span id="line-538"></span><span>
</span><span id="line-539"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeFamilyDependencies"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeFamilyDependencies"><span class="hs-identifier hs-var">TypeFamilyDependencies</span></a></span></span><span>
</span><span id="line-540"></span><span>
</span><span id="line-541"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="OverloadedLabels"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#OverloadedLabels"><span class="hs-identifier hs-var">OverloadedLabels</span></a></span></span><span>
</span><span id="line-542"></span><span>
</span><span id="line-543"></span><span>  </span><span class="hs-comment">-- | Allow multiple @deriving@ clauses, each optionally qualified with a</span><span>
</span><span id="line-544"></span><span>  </span><span class="hs-comment">-- /strategy/.</span><span>
</span><span id="line-545"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivingStrategies"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DerivingStrategies"><span class="hs-identifier hs-var">DerivingStrategies</span></a></span></span><span>
</span><span id="line-546"></span><span>
</span><span id="line-547"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="UnboxedSums"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnboxedSums"><span class="hs-identifier hs-var">UnboxedSums</span></a></span></span><span>
</span><span id="line-548"></span><span>
</span><span id="line-549"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="TypeInType"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#TypeInType"><span class="hs-identifier hs-var">TypeInType</span></a></span></span><span>
</span><span id="line-550"></span><span>
</span><span id="line-551"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="Strict"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Strict"><span class="hs-identifier hs-var">Strict</span></a></span></span><span>
</span><span id="line-552"></span><span>
</span><span id="line-553"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="StrictData"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#StrictData"><span class="hs-identifier hs-var">StrictData</span></a></span></span><span>
</span><span id="line-554"></span><span>
</span><span id="line-555"></span><span>  </span><span class="hs-comment">-- | Enable deriving instances via types of the same runtime representation.</span><span>
</span><span id="line-556"></span><span>  </span><span class="hs-comment">-- Implies 'DerivingStrategies'.</span><span>
</span><span id="line-557"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="DerivingVia"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DerivingVia"><span class="hs-identifier hs-var">DerivingVia</span></a></span></span><span>
</span><span id="line-558"></span><span>
</span><span id="line-559"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="QuantifiedConstraints"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#QuantifiedConstraints"><span class="hs-identifier hs-var">QuantifiedConstraints</span></a></span></span><span>
</span><span id="line-560"></span><span>
</span><span id="line-561"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span id="BlockArguments"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#BlockArguments"><span class="hs-identifier hs-var">BlockArguments</span></a></span></span><span>
</span><span id="line-562"></span><span>
</span><span id="line-563"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679386802"><span id="local-6989586621679386804"><span id="local-6989586621679386806"><span class="annot"><span class="annottext">Int -&gt; KnownExtension -&gt; ShowS
[KnownExtension] -&gt; ShowS
KnownExtension -&gt; String
(Int -&gt; KnownExtension -&gt; ShowS)
-&gt; (KnownExtension -&gt; String)
-&gt; ([KnownExtension] -&gt; ShowS)
-&gt; Show KnownExtension
forall a.
(Int -&gt; a -&gt; ShowS) -&gt; (a -&gt; String) -&gt; ([a] -&gt; ShowS) -&gt; Show a
showList :: [KnownExtension] -&gt; ShowS
$cshowList :: [KnownExtension] -&gt; ShowS
show :: KnownExtension -&gt; String
$cshow :: KnownExtension -&gt; String
showsPrec :: Int -&gt; KnownExtension -&gt; ShowS
$cshowsPrec :: Int -&gt; KnownExtension -&gt; ShowS
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Show</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386794"><span id="local-6989586621679386796"><span id="local-6989586621679386798"><span id="local-6989586621679386800"><span class="annot"><span class="annottext">ReadPrec [KnownExtension]
ReadPrec KnownExtension
Int -&gt; ReadS KnownExtension
ReadS [KnownExtension]
(Int -&gt; ReadS KnownExtension)
-&gt; ReadS [KnownExtension]
-&gt; ReadPrec KnownExtension
-&gt; ReadPrec [KnownExtension]
-&gt; Read KnownExtension
forall a.
(Int -&gt; ReadS a)
-&gt; ReadS [a] -&gt; ReadPrec a -&gt; ReadPrec [a] -&gt; Read a
readListPrec :: ReadPrec [KnownExtension]
$creadListPrec :: ReadPrec [KnownExtension]
readPrec :: ReadPrec KnownExtension
$creadPrec :: ReadPrec KnownExtension
readList :: ReadS [KnownExtension]
$creadList :: ReadS [KnownExtension]
readsPrec :: Int -&gt; ReadS KnownExtension
$creadsPrec :: Int -&gt; ReadS KnownExtension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Read</span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386790"><span id="local-6989586621679386792"><span class="annot"><span class="annottext">KnownExtension -&gt; KnownExtension -&gt; Bool
(KnownExtension -&gt; KnownExtension -&gt; Bool)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Bool) -&gt; Eq KnownExtension
forall a. (a -&gt; a -&gt; Bool) -&gt; (a -&gt; a -&gt; Bool) -&gt; Eq a
/= :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c/= :: KnownExtension -&gt; KnownExtension -&gt; Bool
== :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c== :: KnownExtension -&gt; KnownExtension -&gt; Bool
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Eq</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386775"><span id="local-6989586621679386777"><span id="local-6989586621679386779"><span id="local-6989586621679386781"><span id="local-6989586621679386783"><span id="local-6989586621679386785"><span id="local-6989586621679386787"><span class="annot"><span class="annottext">Eq KnownExtension
Eq KnownExtension
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Ordering)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Bool)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Bool)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Bool)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; Bool)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; KnownExtension)
-&gt; (KnownExtension -&gt; KnownExtension -&gt; KnownExtension)
-&gt; Ord KnownExtension
KnownExtension -&gt; KnownExtension -&gt; Bool
KnownExtension -&gt; KnownExtension -&gt; Ordering
KnownExtension -&gt; KnownExtension -&gt; KnownExtension
forall a.
Eq a
-&gt; (a -&gt; a -&gt; Ordering)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; Bool)
-&gt; (a -&gt; a -&gt; a)
-&gt; (a -&gt; a -&gt; a)
-&gt; Ord a
min :: KnownExtension -&gt; KnownExtension -&gt; KnownExtension
$cmin :: KnownExtension -&gt; KnownExtension -&gt; KnownExtension
max :: KnownExtension -&gt; KnownExtension -&gt; KnownExtension
$cmax :: KnownExtension -&gt; KnownExtension -&gt; KnownExtension
&gt;= :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c&gt;= :: KnownExtension -&gt; KnownExtension -&gt; Bool
&gt; :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c&gt; :: KnownExtension -&gt; KnownExtension -&gt; Bool
&lt;= :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c&lt;= :: KnownExtension -&gt; KnownExtension -&gt; Bool
&lt; :: KnownExtension -&gt; KnownExtension -&gt; Bool
$c&lt; :: KnownExtension -&gt; KnownExtension -&gt; Bool
compare :: KnownExtension -&gt; KnownExtension -&gt; Ordering
$ccompare :: KnownExtension -&gt; KnownExtension -&gt; Ordering
$cp1Ord :: Eq KnownExtension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Ord</span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386759"><span id="local-6989586621679386761"><span id="local-6989586621679386763"><span id="local-6989586621679386765"><span id="local-6989586621679386767"><span id="local-6989586621679386769"><span id="local-6989586621679386771"><span id="local-6989586621679386773"><span class="annot"><span class="annottext">Int -&gt; KnownExtension
KnownExtension -&gt; Int
KnownExtension -&gt; [KnownExtension]
KnownExtension -&gt; KnownExtension
KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
KnownExtension
-&gt; KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
(KnownExtension -&gt; KnownExtension)
-&gt; (KnownExtension -&gt; KnownExtension)
-&gt; (Int -&gt; KnownExtension)
-&gt; (KnownExtension -&gt; Int)
-&gt; (KnownExtension -&gt; [KnownExtension])
-&gt; (KnownExtension -&gt; KnownExtension -&gt; [KnownExtension])
-&gt; (KnownExtension -&gt; KnownExtension -&gt; [KnownExtension])
-&gt; (KnownExtension
    -&gt; KnownExtension -&gt; KnownExtension -&gt; [KnownExtension])
-&gt; Enum KnownExtension
forall a.
(a -&gt; a)
-&gt; (a -&gt; a)
-&gt; (Int -&gt; a)
-&gt; (a -&gt; Int)
-&gt; (a -&gt; [a])
-&gt; (a -&gt; a -&gt; [a])
-&gt; (a -&gt; a -&gt; [a])
-&gt; (a -&gt; a -&gt; a -&gt; [a])
-&gt; Enum a
enumFromThenTo :: KnownExtension
-&gt; KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
$cenumFromThenTo :: KnownExtension
-&gt; KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
enumFromTo :: KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
$cenumFromTo :: KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
enumFromThen :: KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
$cenumFromThen :: KnownExtension -&gt; KnownExtension -&gt; [KnownExtension]
enumFrom :: KnownExtension -&gt; [KnownExtension]
$cenumFrom :: KnownExtension -&gt; [KnownExtension]
fromEnum :: KnownExtension -&gt; Int
$cfromEnum :: KnownExtension -&gt; Int
toEnum :: Int -&gt; KnownExtension
$ctoEnum :: Int -&gt; KnownExtension
pred :: KnownExtension -&gt; KnownExtension
$cpred :: KnownExtension -&gt; KnownExtension
succ :: KnownExtension -&gt; KnownExtension
$csucc :: KnownExtension -&gt; KnownExtension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Enum</span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621679386754"><span id="local-6989586621679386756"><span class="annot"><span class="annottext">KnownExtension
KnownExtension -&gt; KnownExtension -&gt; Bounded KnownExtension
forall a. a -&gt; a -&gt; Bounded a
maxBound :: KnownExtension
$cmaxBound :: KnownExtension
minBound :: KnownExtension
$cminBound :: KnownExtension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Bounded</span></span></span></span><span class="hs-special">,</span><span> </span><span id="%24cBlockArguments"><span id="%24cQuantifiedConstraints"><span id="%24cDerivingVia"><span id="%24cStrictData"><span id="%24cStrict"><span id="%24cTypeInType"><span id="%24cUnboxedSums"><span id="%24cDerivingStrategies"><span id="%24cOverloadedLabels"><span id="%24cTypeFamilyDependencies"><span id="%24cTypeApplications"><span id="%24cNamedWildCards"><span id="%24cPartialTypeSignatures"><span id="%24cPatternSynonyms"><span id="%24cRoleAnnotations"><span id="%24cConstraintKinds"><span id="%24cDefaultSignatures"><span id="%24cTrustworthy"><span id="%24cSafe"><span id="%24cSafeImports"><span id="%24cMultiWayIf"><span id="%24cPolyKinds"><span id="%24cDataKinds"><span id="%24cExplicitNamespaces"><span id="%24cJavaScriptFFI"><span id="%24cCApiFFI"><span id="%24cInterruptibleFFI"><span id="%24cNondecreasingIndentation"><span id="%24cDeriveFoldable"><span id="%24cDeriveTraversable"><span id="%24cDeriveGeneric"><span id="%24cDeriveFunctor"><span id="%24cMonoLocalBinds"><span id="%24cDatatypeContexts"><span id="%24cExplicitForAll"><span id="%24cRebindableSyntax"><span id="%24cDoAndIfThenElse"><span id="%24cNPlusKPatterns"><span id="%24cGHCForeignImportPrim"><span id="%24cTupleSections"><span id="%24cRegularPatterns"><span id="%24cXmlSyntax"><span id="%24cViewPatterns"><span id="%24cTransformListComp"><span id="%24cQuasiQuotes"><span id="%24cPostfixOperators"><span id="%24cNewQualifiedOperators"><span id="%24cImpredicativeTypes"><span id="%24cEmptyCase"><span id="%24cLambdaCase"><span id="%24cPackageImports"><span id="%24cConstrainedClassMethods"><span id="%24cDeriveDataTypeable"><span id="%24cUnboxedTuples"><span id="%24cExtendedDefaultRules"><span id="%24cRelaxedPolyRec"><span id="%24cMonoPatBinds"><span id="%24cGADTs"><span id="%24cOverloadedStrings"><span id="%24cDisambiguateRecordFields"><span id="%24cRecordPuns"><span id="%24cRecordWildCards"><span id="%24cParallelArrays"><span id="%24cTypeOperators"><span id="%24cLiberalTypeSynonyms"><span id="%24cUnliftedFFITypes"><span id="%24cUnicodeSyntax"><span id="%24cStandaloneDeriving"><span id="%24cTypeFamilies"><span id="%24cBinaryLiterals"><span id="%24cMagicHash"><span id="%24cHereDocuments"><span id="%24cRestrictedTypeSynonyms"><span id="%24cExtensibleRecords"><span id="%24cDeriveAnyClass"><span id="%24cGeneralizedNewtypeDeriving"><span id="%24cPatternGuards"><span id="%24cNamedFieldPuns"><span id="%24cImplicitPrelude"><span id="%24cGenerics"><span id="%24cArrows"><span id="%24cForeignFunctionInterface"><span id="%24cTemplateHaskell"><span id="%24cTypeSynonymInstances"><span id="%24cBangPatterns"><span id="%24cKindSignatures"><span id="%24cCPP"><span id="%24cEmptyDataDecls"><span id="%24cFlexibleInstances"><span id="%24cFlexibleContexts"><span id="%24cImplicitParams"><span id="%24cPatternSignatures"><span id="%24cScopedTypeVariables"><span id="%24cExistentialQuantification"><span id="%24cPolymorphicComponents"><span id="%24cRankNTypes"><span id="%24cRank2Types"><span id="%24cFunctionalDependencies"><span id="%24cMonomorphismRestriction"><span id="%24cMultiParamTypeClasses"><span id="%24cParallelListComp"><span id="%24cRecursiveDo"><span id="%24cDoRec"><span id="%24cInstanceSigs"><span id="%24cIncoherentInstances"><span id="%24cUndecidableInstances"><span id="%24cOverlappingInstances"><span id="%24tKnownExtension"><span id="local-6989586621679386724"><span id="local-6989586621679386726"><span id="local-6989586621679386728"><span id="local-6989586621679386730"><span id="local-6989586621679386732"><span id="local-6989586621679386734"><span id="local-6989586621679386736"><span id="local-6989586621679386738"><span id="local-6989586621679386740"><span id="local-6989586621679386742"><span id="local-6989586621679386744"><span id="local-6989586621679386746"><span id="local-6989586621679386748"><span id="local-6989586621679386750"><span class="annot"><span class="annottext">Typeable KnownExtension
DataType
Constr
Typeable KnownExtension
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; KnownExtension -&gt; c KnownExtension)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c KnownExtension)
-&gt; (KnownExtension -&gt; Constr)
-&gt; (KnownExtension -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c KnownExtension))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e))
    -&gt; Maybe (c KnownExtension))
-&gt; ((forall b. Data b =&gt; b -&gt; b)
    -&gt; KnownExtension -&gt; KnownExtension)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r)
    -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r)
-&gt; (forall u.
    (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; [u])
-&gt; (forall u.
    Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; KnownExtension -&gt; m KnownExtension)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; KnownExtension -&gt; m KnownExtension)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d)
    -&gt; KnownExtension -&gt; m KnownExtension)
-&gt; Data KnownExtension
KnownExtension -&gt; DataType
KnownExtension -&gt; Constr
(forall b. Data b =&gt; b -&gt; b) -&gt; KnownExtension -&gt; KnownExtension
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; KnownExtension -&gt; c KnownExtension
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c KnownExtension
forall a.
Typeable a
-&gt; (forall (c :: * -&gt; *).
    (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
    -&gt; (forall g. g -&gt; c g) -&gt; a -&gt; c a)
-&gt; (forall (c :: * -&gt; *).
    (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
    -&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c a)
-&gt; (a -&gt; Constr)
-&gt; (a -&gt; DataType)
-&gt; (forall (t :: * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c a))
-&gt; (forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
    Typeable t =&gt;
    (forall d e. (Data d, Data e) =&gt; c (t d e)) -&gt; Maybe (c a))
-&gt; ((forall b. Data b =&gt; b -&gt; b) -&gt; a -&gt; a)
-&gt; (forall r r'.
    (r -&gt; r' -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall r r'.
    (r' -&gt; r -&gt; r) -&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; a -&gt; r)
-&gt; (forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; [u])
-&gt; (forall u. Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; a -&gt; u)
-&gt; (forall (m :: * -&gt; *).
    Monad m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; (forall (m :: * -&gt; *).
    MonadPlus m =&gt;
    (forall d. Data d =&gt; d -&gt; m d) -&gt; a -&gt; m a)
-&gt; Data a
forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; u
forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; [u]
forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c KnownExtension
forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; KnownExtension -&gt; c KnownExtension
forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c KnownExtension)
forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c KnownExtension)
$cBlockArguments :: Constr
$cQuantifiedConstraints :: Constr
$cDerivingVia :: Constr
$cStrictData :: Constr
$cStrict :: Constr
$cTypeInType :: Constr
$cUnboxedSums :: Constr
$cDerivingStrategies :: Constr
$cOverloadedLabels :: Constr
$cTypeFamilyDependencies :: Constr
$cTypeApplications :: Constr
$cNamedWildCards :: Constr
$cPartialTypeSignatures :: Constr
$cPatternSynonyms :: Constr
$cRoleAnnotations :: Constr
$cConstraintKinds :: Constr
$cDefaultSignatures :: Constr
$cTrustworthy :: Constr
$cSafe :: Constr
$cSafeImports :: Constr
$cMultiWayIf :: Constr
$cPolyKinds :: Constr
$cDataKinds :: Constr
$cExplicitNamespaces :: Constr
$cJavaScriptFFI :: Constr
$cCApiFFI :: Constr
$cInterruptibleFFI :: Constr
$cNondecreasingIndentation :: Constr
$cDeriveFoldable :: Constr
$cDeriveTraversable :: Constr
$cDeriveGeneric :: Constr
$cDeriveFunctor :: Constr
$cMonoLocalBinds :: Constr
$cDatatypeContexts :: Constr
$cExplicitForAll :: Constr
$cRebindableSyntax :: Constr
$cDoAndIfThenElse :: Constr
$cNPlusKPatterns :: Constr
$cGHCForeignImportPrim :: Constr
$cTupleSections :: Constr
$cRegularPatterns :: Constr
$cXmlSyntax :: Constr
$cViewPatterns :: Constr
$cTransformListComp :: Constr
$cQuasiQuotes :: Constr
$cPostfixOperators :: Constr
$cNewQualifiedOperators :: Constr
$cImpredicativeTypes :: Constr
$cEmptyCase :: Constr
$cLambdaCase :: Constr
$cPackageImports :: Constr
$cConstrainedClassMethods :: Constr
$cDeriveDataTypeable :: Constr
$cUnboxedTuples :: Constr
$cExtendedDefaultRules :: Constr
$cRelaxedPolyRec :: Constr
$cMonoPatBinds :: Constr
$cGADTs :: Constr
$cOverloadedStrings :: Constr
$cDisambiguateRecordFields :: Constr
$cRecordPuns :: Constr
$cRecordWildCards :: Constr
$cParallelArrays :: Constr
$cTypeOperators :: Constr
$cLiberalTypeSynonyms :: Constr
$cUnliftedFFITypes :: Constr
$cUnicodeSyntax :: Constr
$cStandaloneDeriving :: Constr
$cTypeFamilies :: Constr
$cBinaryLiterals :: Constr
$cMagicHash :: Constr
$cHereDocuments :: Constr
$cRestrictedTypeSynonyms :: Constr
$cExtensibleRecords :: Constr
$cDeriveAnyClass :: Constr
$cGeneralizedNewtypeDeriving :: Constr
$cPatternGuards :: Constr
$cNamedFieldPuns :: Constr
$cImplicitPrelude :: Constr
$cGenerics :: Constr
$cArrows :: Constr
$cForeignFunctionInterface :: Constr
$cTemplateHaskell :: Constr
$cTypeSynonymInstances :: Constr
$cBangPatterns :: Constr
$cKindSignatures :: Constr
$cCPP :: Constr
$cEmptyDataDecls :: Constr
$cFlexibleInstances :: Constr
$cFlexibleContexts :: Constr
$cImplicitParams :: Constr
$cPatternSignatures :: Constr
$cScopedTypeVariables :: Constr
$cExistentialQuantification :: Constr
$cPolymorphicComponents :: Constr
$cRankNTypes :: Constr
$cRank2Types :: Constr
$cFunctionalDependencies :: Constr
$cMonomorphismRestriction :: Constr
$cMultiParamTypeClasses :: Constr
$cParallelListComp :: Constr
$cRecursiveDo :: Constr
$cDoRec :: Constr
$cInstanceSigs :: Constr
$cIncoherentInstances :: Constr
$cUndecidableInstances :: Constr
$cOverlappingInstances :: Constr
$tKnownExtension :: DataType
gmapMo :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
$cgmapMo :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
gmapMp :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
$cgmapMp :: forall (m :: * -&gt; *).
MonadPlus m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
gmapM :: (forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
$cgmapM :: forall (m :: * -&gt; *).
Monad m =&gt;
(forall d. Data d =&gt; d -&gt; m d)
-&gt; KnownExtension -&gt; m KnownExtension
gmapQi :: Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; u
$cgmapQi :: forall u.
Int -&gt; (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; u
gmapQ :: (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; [u]
$cgmapQ :: forall u. (forall d. Data d =&gt; d -&gt; u) -&gt; KnownExtension -&gt; [u]
gmapQr :: (r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
$cgmapQr :: forall r r'.
(r' -&gt; r -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
gmapQl :: (r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
$cgmapQl :: forall r r'.
(r -&gt; r' -&gt; r)
-&gt; r -&gt; (forall d. Data d =&gt; d -&gt; r') -&gt; KnownExtension -&gt; r
gmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; KnownExtension -&gt; KnownExtension
$cgmapT :: (forall b. Data b =&gt; b -&gt; b) -&gt; KnownExtension -&gt; KnownExtension
dataCast2 :: (forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c KnownExtension)
$cdataCast2 :: forall (t :: * -&gt; * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d e. (Data d, Data e) =&gt; c (t d e))
-&gt; Maybe (c KnownExtension)
dataCast1 :: (forall d. Data d =&gt; c (t d)) -&gt; Maybe (c KnownExtension)
$cdataCast1 :: forall (t :: * -&gt; *) (c :: * -&gt; *).
Typeable t =&gt;
(forall d. Data d =&gt; c (t d)) -&gt; Maybe (c KnownExtension)
dataTypeOf :: KnownExtension -&gt; DataType
$cdataTypeOf :: KnownExtension -&gt; DataType
toConstr :: KnownExtension -&gt; Constr
$ctoConstr :: KnownExtension -&gt; Constr
gunfold :: (forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c KnownExtension
$cgunfold :: forall (c :: * -&gt; *).
(forall b r. Data b =&gt; c (b -&gt; r) -&gt; c r)
-&gt; (forall r. r -&gt; c r) -&gt; Constr -&gt; c KnownExtension
gfoldl :: (forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; KnownExtension -&gt; c KnownExtension
$cgfoldl :: forall (c :: * -&gt; *).
(forall d b. Data d =&gt; c (d -&gt; b) -&gt; d -&gt; c b)
-&gt; (forall g. g -&gt; c g) -&gt; KnownExtension -&gt; c KnownExtension
$cp1Data :: Typeable KnownExtension
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Data</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span class="hs-special">)</span><span>
</span><span id="line-564"></span><span>
</span><span id="line-565"></span><span class="hs-comment">-- | Certain extensions imply other extensions, and this function</span><span>
</span><span id="line-566"></span><span class="hs-comment">--   makes the implication explicit. This also handles deprecated</span><span>
</span><span id="line-567"></span><span class="hs-comment">--   extensions, which imply their replacements.</span><span>
</span><span id="line-568"></span><span class="hs-comment">--   The returned value is the transitive closure of implied</span><span>
</span><span id="line-569"></span><span class="hs-comment">--   extensions.</span><span>
</span><span id="line-570"></span><span class="hs-comment">{-impliesExts :: [Extension] -&gt; [Extension]
impliesExts exts =
    let posExts = [ ke | EnableExtension  ke &lt;- exts ]
        negExts = [ ke | DisableExtension ke &lt;- exts ]

        implExts = impliesKnownExts posExts
     in
-}</span><span>
</span><span id="line-578"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#impliesExts"><span class="hs-identifier hs-type">impliesExts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-579"></span><span id="impliesExts"><span class="annot"><span class="annottext">impliesExts :: [KnownExtension] -&gt; [KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#impliesExts"><span class="hs-identifier hs-var hs-var">impliesExts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386615"><span class="hs-identifier hs-var">go</span></a></span><span>
</span><span id="line-580"></span><span>  </span><span class="hs-keyword">where</span><span> </span><span id="local-6989586621679386615"><span class="annot"><span class="annottext">go :: [KnownExtension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386615"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-581"></span><span>        </span><span class="annot"><a href="#local-6989586621679386615"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679386614"><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386614"><span class="hs-identifier hs-var">es</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679386613"><span class="annot"><span class="annottext">xs :: [KnownExtension]
</span><a href="#local-6989586621679386613"><span class="hs-identifier hs-var hs-var">xs</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; [KnownExtension])
-&gt; [KnownExtension] -&gt; [KnownExtension]
forall (t :: * -&gt; *) a b. Foldable t =&gt; (a -&gt; [b]) -&gt; t a -&gt; [b]
</span><span class="hs-identifier hs-var">concatMap</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; [KnownExtension]
</span><a href="#local-6989586621679386611"><span class="hs-identifier hs-var">implE</span></a></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386614"><span class="hs-identifier hs-var">es</span></a></span><span>
</span><span id="line-582"></span><span>                    </span><span id="local-6989586621679386610"><span class="annot"><span class="annottext">ys :: [KnownExtension]
</span><a href="#local-6989586621679386610"><span class="hs-identifier hs-var hs-var">ys</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; Bool) -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Bool -&gt; Bool
</span><span class="hs-identifier hs-var">not</span></span><span> </span><span class="annot"><span class="annottext">(Bool -&gt; Bool)
-&gt; (KnownExtension -&gt; Bool) -&gt; KnownExtension -&gt; Bool
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; [KnownExtension] -&gt; Bool)
-&gt; [KnownExtension] -&gt; KnownExtension -&gt; Bool
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; [KnownExtension] -&gt; Bool
forall (t :: * -&gt; *) a. (Foldable t, Eq a) =&gt; a -&gt; t a -&gt; Bool
</span><span class="hs-identifier hs-var">elem</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386614"><span class="hs-identifier hs-var">es</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386613"><span class="hs-identifier hs-var">xs</span></a></span><span>
</span><span id="line-583"></span><span>                 </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386614"><span class="hs-identifier hs-var">es</span></a></span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386615"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386610"><span class="hs-identifier hs-var">ys</span></a></span><span>
</span><span id="line-584"></span><span>
</span><span id="line-585"></span><span>        </span><span id="local-6989586621679386611"><span class="annot"><span class="annottext">implE :: KnownExtension -&gt; [KnownExtension]
</span><a href="#local-6989586621679386611"><span class="hs-identifier hs-var hs-var">implE</span></a></span></span><span> </span><span id="local-6989586621679386605"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386605"><span class="hs-identifier hs-var">e</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386605"><span class="hs-identifier hs-var">e</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-586"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeFamilies"><span class="hs-identifier hs-var">TypeFamilies</span></a></span><span>        </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#KindSignatures"><span class="hs-identifier hs-var">KindSignatures</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-587"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ScopedTypeVariables"><span class="hs-identifier hs-var">ScopedTypeVariables</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeOperators"><span class="hs-identifier hs-var">TypeOperators</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-588"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#XmlSyntax"><span class="hs-identifier hs-var">XmlSyntax</span></a></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RegularPatterns"><span class="hs-identifier hs-var">RegularPatterns</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-589"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RegularPatterns"><span class="hs-identifier hs-var">RegularPatterns</span></a></span><span>     </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PatternGuards"><span class="hs-identifier hs-var">PatternGuards</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-590"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RankNTypes"><span class="hs-identifier hs-var">RankNTypes</span></a></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#Rank2Types"><span class="hs-identifier hs-var">Rank2Types</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-591"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#Rank2Types"><span class="hs-identifier hs-var">Rank2Types</span></a></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PolymorphicComponents"><span class="hs-identifier hs-var">PolymorphicComponents</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-592"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PolymorphicComponents"><span class="hs-identifier hs-var">PolymorphicComponents</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-593"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#LiberalTypeSynonyms"><span class="hs-identifier hs-var">LiberalTypeSynonyms</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-594"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExistentialQuantification"><span class="hs-identifier hs-var">ExistentialQuantification</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-595"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ImpredicativeTypes"><span class="hs-identifier hs-var">ImpredicativeTypes</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitForAll"><span class="hs-identifier hs-var">ExplicitForAll</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-596"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PolyKinds"><span class="hs-identifier hs-var">PolyKinds</span></a></span><span>           </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#KindSignatures"><span class="hs-identifier hs-var">KindSignatures</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-597"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeFamilyDependencies"><span class="hs-identifier hs-var">TypeFamilyDependencies</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeFamilies"><span class="hs-identifier hs-var">TypeFamilies</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-598"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeInType"><span class="hs-identifier hs-var">TypeInType</span></a></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PolyKinds"><span class="hs-identifier hs-var">PolyKinds</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#DataKinds"><span class="hs-identifier hs-var">DataKinds</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#KindSignatures"><span class="hs-identifier hs-var">KindSignatures</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-599"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeOperators"><span class="hs-identifier hs-var">TypeOperators</span></a></span><span>       </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExplicitNamespaces"><span class="hs-identifier hs-var">ExplicitNamespaces</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-600"></span><span>                    </span><span class="hs-comment">-- Deprecations</span><span>
</span><span id="line-601"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RecordPuns"><span class="hs-identifier hs-var">RecordPuns</span></a></span><span>          </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#NamedFieldPuns"><span class="hs-identifier hs-var">NamedFieldPuns</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-602"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PatternSignatures"><span class="hs-identifier hs-var">PatternSignatures</span></a></span><span>   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ScopedTypeVariables"><span class="hs-identifier hs-var">ScopedTypeVariables</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-603"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#DerivingVia"><span class="hs-identifier hs-var">DerivingVia</span></a></span><span>         </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#DerivingStrategies"><span class="hs-identifier hs-var">DerivingStrategies</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-604"></span><span>                    </span><span class="annot"><span class="annottext">KnownExtension
</span><span class="hs-identifier">_</span></span><span>                   </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-605"></span><span>
</span><span id="line-606"></span><span class="hs-comment">-- | The list of extensions enabled by</span><span>
</span><span id="line-607"></span><span class="hs-comment">--   GHC's portmanteau -fglasgow-exts flag.</span><span>
</span><span id="line-608"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#glasgowExts"><span class="hs-identifier hs-type">glasgowExts</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-609"></span><span id="glasgowExts"><span class="annot"><span class="annottext">glasgowExts :: [Extension]
</span><a href="Language.Haskell.Exts.Extension.html#glasgowExts"><span class="hs-identifier hs-var hs-var">glasgowExts</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; Extension) -&gt; [KnownExtension] -&gt; [Extension]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="hs-special">[</span><span>
</span><span id="line-610"></span><span>      </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ForeignFunctionInterface"><span class="hs-identifier hs-var">ForeignFunctionInterface</span></a></span><span>
</span><span id="line-611"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#UnliftedFFITypes"><span class="hs-identifier hs-var">UnliftedFFITypes</span></a></span><span>
</span><span id="line-612"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#GADTs"><span class="hs-identifier hs-var">GADTs</span></a></span><span>
</span><span id="line-613"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ImplicitParams"><span class="hs-identifier hs-var">ImplicitParams</span></a></span><span>
</span><span id="line-614"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ScopedTypeVariables"><span class="hs-identifier hs-var">ScopedTypeVariables</span></a></span><span>
</span><span id="line-615"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#UnboxedTuples"><span class="hs-identifier hs-var">UnboxedTuples</span></a></span><span>
</span><span id="line-616"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeSynonymInstances"><span class="hs-identifier hs-var">TypeSynonymInstances</span></a></span><span>
</span><span id="line-617"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#StandaloneDeriving"><span class="hs-identifier hs-var">StandaloneDeriving</span></a></span><span>
</span><span id="line-618"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#DeriveDataTypeable"><span class="hs-identifier hs-var">DeriveDataTypeable</span></a></span><span>
</span><span id="line-619"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#FlexibleContexts"><span class="hs-identifier hs-var">FlexibleContexts</span></a></span><span>
</span><span id="line-620"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#FlexibleInstances"><span class="hs-identifier hs-var">FlexibleInstances</span></a></span><span>
</span><span id="line-621"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ConstrainedClassMethods"><span class="hs-identifier hs-var">ConstrainedClassMethods</span></a></span><span>
</span><span id="line-622"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#MultiParamTypeClasses"><span class="hs-identifier hs-var">MultiParamTypeClasses</span></a></span><span>
</span><span id="line-623"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#FunctionalDependencies"><span class="hs-identifier hs-var">FunctionalDependencies</span></a></span><span>
</span><span id="line-624"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#MagicHash"><span class="hs-identifier hs-var">MagicHash</span></a></span><span>
</span><span id="line-625"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PolymorphicComponents"><span class="hs-identifier hs-var">PolymorphicComponents</span></a></span><span>
</span><span id="line-626"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ExistentialQuantification"><span class="hs-identifier hs-var">ExistentialQuantification</span></a></span><span>
</span><span id="line-627"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#UnicodeSyntax"><span class="hs-identifier hs-var">UnicodeSyntax</span></a></span><span>
</span><span id="line-628"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PostfixOperators"><span class="hs-identifier hs-var">PostfixOperators</span></a></span><span>
</span><span id="line-629"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PatternGuards"><span class="hs-identifier hs-var">PatternGuards</span></a></span><span>
</span><span id="line-630"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#LiberalTypeSynonyms"><span class="hs-identifier hs-var">LiberalTypeSynonyms</span></a></span><span>
</span><span id="line-631"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RankNTypes"><span class="hs-identifier hs-var">RankNTypes</span></a></span><span>
</span><span id="line-632"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ImpredicativeTypes"><span class="hs-identifier hs-var">ImpredicativeTypes</span></a></span><span>
</span><span id="line-633"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeOperators"><span class="hs-identifier hs-var">TypeOperators</span></a></span><span>
</span><span id="line-634"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RecursiveDo"><span class="hs-identifier hs-var">RecursiveDo</span></a></span><span>
</span><span id="line-635"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ParallelListComp"><span class="hs-identifier hs-var">ParallelListComp</span></a></span><span>
</span><span id="line-636"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#EmptyDataDecls"><span class="hs-identifier hs-var">EmptyDataDecls</span></a></span><span>
</span><span id="line-637"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#KindSignatures"><span class="hs-identifier hs-var">KindSignatures</span></a></span><span>
</span><span id="line-638"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#GeneralizedNewtypeDeriving"><span class="hs-identifier hs-var">GeneralizedNewtypeDeriving</span></a></span><span>
</span><span id="line-639"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#TypeFamilies"><span class="hs-identifier hs-var">TypeFamilies</span></a></span><span>
</span><span id="line-640"></span><span>    </span><span class="hs-special">]</span><span>
</span><span id="line-641"></span><span>
</span><span id="line-642"></span><span class="hs-comment">-- Not exported, just used locally in several places.</span><span>
</span><span id="line-643"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#allLangDefault"><span class="hs-identifier hs-type">allLangDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-644"></span><span id="allLangDefault"><span class="annot"><span class="annottext">allLangDefault :: [KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#allLangDefault"><span class="hs-identifier hs-var hs-var">allLangDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#MonomorphismRestriction"><span class="hs-identifier hs-var">MonomorphismRestriction</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#MonoPatBinds"><span class="hs-identifier hs-var">MonoPatBinds</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ImplicitPrelude"><span class="hs-identifier hs-var">ImplicitPrelude</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-645"></span><span>
</span><span id="line-646"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#ghcDefault"><span class="hs-identifier hs-type">ghcDefault</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-647"></span><span id="ghcDefault"><span class="annot"><span class="annottext">ghcDefault :: [Extension]
</span><a href="Language.Haskell.Exts.Extension.html#ghcDefault"><span class="hs-identifier hs-var hs-var">ghcDefault</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; Extension) -&gt; [KnownExtension] -&gt; [Extension]
forall a b. (a -&gt; b) -&gt; [a] -&gt; [b]
</span><span class="hs-identifier hs-var">map</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#NondecreasingIndentation"><span class="hs-identifier hs-var">NondecreasingIndentation</span></a></span><span class="annot"><span class="annottext">KnownExtension -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#allLangDefault"><span class="hs-identifier hs-var">allLangDefault</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-648"></span><span>
</span><span id="line-649"></span><span class="hs-comment">-- | List of all known extensions, both \&quot;yes\&quot; and \&quot;no\&quot; versions.</span><span>
</span><span id="line-650"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#knownExtensions"><span class="hs-identifier hs-type">knownExtensions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-651"></span><span id="knownExtensions"><span class="annot"><span class="annottext">knownExtensions :: [Extension]
</span><a href="Language.Haskell.Exts.Extension.html#knownExtensions"><span class="hs-identifier hs-var hs-var">knownExtensions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-652"></span><span>  </span><span class="annot"><span class="annottext">[[Extension]] -&gt; [Extension]
forall (t :: * -&gt; *) a. Foldable t =&gt; t [a] -&gt; [a]
</span><span class="hs-identifier hs-var">concat</span></span><span> </span><span class="hs-special">[</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386602"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-var">DisableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386602"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679386602"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386602"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
forall a. Bounded a =&gt; a
</span><span class="hs-identifier hs-var">minBound</span></span><span class="hs-glyph">..</span><span class="annot"><span class="annottext">KnownExtension
forall a. Bounded a =&gt; a
</span><span class="hs-identifier hs-var">maxBound</span></span><span class="hs-special">]</span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-653"></span><span>
</span><span id="line-654"></span><span class="hs-comment">-- | Extensions that have been deprecated, possibly paired with another</span><span>
</span><span id="line-655"></span><span class="hs-comment">-- extension that replaces it.</span><span>
</span><span id="line-656"></span><span class="hs-comment">--</span><span>
</span><span id="line-657"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#deprecatedExtensions"><span class="hs-identifier hs-type">deprecatedExtensions</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-658"></span><span id="deprecatedExtensions"><span class="annot"><span class="annottext">deprecatedExtensions :: [(Extension, Maybe Extension)]
</span><a href="Language.Haskell.Exts.Extension.html#deprecatedExtensions"><span class="hs-identifier hs-var hs-var">deprecatedExtensions</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-659"></span><span>  </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#RecordPuns"><span class="hs-identifier hs-var">RecordPuns</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Extension -&gt; Maybe Extension
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#NamedFieldPuns"><span class="hs-identifier hs-var">NamedFieldPuns</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-660"></span><span>  </span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PatternSignatures"><span class="hs-identifier hs-var">PatternSignatures</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Extension -&gt; Maybe Extension
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ScopedTypeVariables"><span class="hs-identifier hs-var">ScopedTypeVariables</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-661"></span><span>  </span><span class="hs-special">]</span><span>
</span><span id="line-662"></span><span>
</span><span id="line-663"></span><span>
</span><span id="line-664"></span><span>
</span><span id="line-665"></span><span class="hs-comment">-- | A clever version of read that returns an 'UnknownExtension'</span><span>
</span><span id="line-666"></span><span class="hs-comment">--   if the string is not recognised.</span><span>
</span><span id="line-667"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyExtension"><span class="hs-identifier hs-type">classifyExtension</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span>
</span><span id="line-668"></span><span id="classifyExtension"><span class="annot"><span class="annottext">classifyExtension :: String -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#classifyExtension"><span class="hs-identifier hs-var hs-var">classifyExtension</span></a></span></span><span> </span><span id="local-6989586621679386599"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386599"><span class="hs-identifier hs-var">string</span></a></span></span><span>
</span><span id="line-669"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#classifyKnownExtension"><span class="hs-identifier hs-var">classifyKnownExtension</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386599"><span class="hs-identifier hs-var">string</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-670"></span><span>    </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679386597"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386597"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386597"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-671"></span><span>    </span><span class="annot"><span class="annottext">Maybe KnownExtension
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-672"></span><span>        </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386599"><span class="hs-identifier hs-var">string</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-673"></span><span>        </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'N'</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'o'</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679386596"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386596"><span class="hs-identifier hs-var">string'</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-674"></span><span>            </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#classifyKnownExtension"><span class="hs-identifier hs-var">classifyKnownExtension</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386596"><span class="hs-identifier hs-var">string'</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-675"></span><span>            </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621679386595"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386595"><span class="hs-identifier hs-var">ext</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-var">DisableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386595"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-676"></span><span>            </span><span class="annot"><span class="annottext">Maybe KnownExtension
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#UnknownExtension"><span class="hs-identifier hs-var">UnknownExtension</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386599"><span class="hs-identifier hs-var">string</span></a></span><span>
</span><span id="line-677"></span><span>        </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">String -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#UnknownExtension"><span class="hs-identifier hs-var">UnknownExtension</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386599"><span class="hs-identifier hs-var">string</span></a></span><span>
</span><span id="line-678"></span><span>
</span><span id="line-679"></span><span>
</span><span id="line-680"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyKnownExtension"><span class="hs-identifier hs-type">classifyKnownExtension</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span>
</span><span id="line-681"></span><span id="classifyKnownExtension"><span class="annot"><span class="annottext">classifyKnownExtension :: String -&gt; Maybe KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#classifyKnownExtension"><span class="hs-identifier hs-var hs-var">classifyKnownExtension</span></a></span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe KnownExtension
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-682"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#classifyKnownExtension"><span class="hs-identifier hs-var">classifyKnownExtension</span></a></span><span> </span><span id="local-6989586621679386594"><span class="annot"><span class="annottext">string :: String
</span><a href="#local-6989586621679386594"><span class="hs-identifier hs-var">string</span></a></span></span><span class="hs-glyph">@</span><span class="hs-special">(</span><span id="local-6989586621679386593"><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679386593"><span class="hs-identifier hs-var">c</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span class="hs-special">)</span><span>
</span><span id="line-683"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">(Char, Char) -&gt; Char -&gt; Bool
forall a. Ix a =&gt; (a, a) -&gt; a -&gt; Bool
</span><span class="hs-identifier hs-var">inRange</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Array Char [(String, KnownExtension)] -&gt; (Char, Char)
forall i e. Array i e -&gt; (i, i)
</span><span class="hs-identifier hs-var">bounds</span></span><span> </span><span class="annot"><span class="annottext">Array Char [(String, KnownExtension)]
</span><a href="Language.Haskell.Exts.Extension.html#knownExtensionTable"><span class="hs-identifier hs-var">knownExtensionTable</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679386593"><span class="hs-identifier hs-var">c</span></a></span><span>
</span><span id="line-684"></span><span>  </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; [(String, KnownExtension)] -&gt; Maybe KnownExtension
forall a b. Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
</span><span class="hs-identifier hs-var">lookup</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386594"><span class="hs-identifier hs-var">string</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Array Char [(String, KnownExtension)]
</span><a href="Language.Haskell.Exts.Extension.html#knownExtensionTable"><span class="hs-identifier hs-var">knownExtensionTable</span></a></span><span> </span><span class="annot"><span class="annottext">Array Char [(String, KnownExtension)]
-&gt; Char -&gt; [(String, KnownExtension)]
forall i e. Ix i =&gt; Array i e -&gt; i -&gt; e
</span><span class="hs-glyph hs-var">!</span></span><span> </span><span class="annot"><span class="annottext">Char
</span><a href="#local-6989586621679386593"><span class="hs-identifier hs-var">c</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-685"></span><span>  </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe KnownExtension
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-686"></span><span>
</span><span id="line-687"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#knownExtensionTable"><span class="hs-identifier hs-type">knownExtensionTable</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Array</span></span><span> </span><span class="annot"><span class="hs-identifier hs-type">Char</span></span><span> </span><span class="hs-special">[</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">)</span><span class="hs-special">]</span><span>
</span><span id="line-688"></span><span id="knownExtensionTable"><span class="annot"><span class="annottext">knownExtensionTable :: Array Char [(String, KnownExtension)]
</span><a href="Language.Haskell.Exts.Extension.html#knownExtensionTable"><span class="hs-identifier hs-var hs-var">knownExtensionTable</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-689"></span><span>  </span><span class="annot"><span class="annottext">([(String, KnownExtension)]
 -&gt; (String, KnownExtension) -&gt; [(String, KnownExtension)])
-&gt; [(String, KnownExtension)]
-&gt; (Char, Char)
-&gt; [(Char, (String, KnownExtension))]
-&gt; Array Char [(String, KnownExtension)]
forall i e a.
Ix i =&gt;
(e -&gt; a -&gt; e) -&gt; e -&gt; (i, i) -&gt; [(i, a)] -&gt; Array i e
</span><span class="hs-identifier hs-var">accumArray</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">((String, KnownExtension)
 -&gt; [(String, KnownExtension)] -&gt; [(String, KnownExtension)])
-&gt; [(String, KnownExtension)]
-&gt; (String, KnownExtension)
-&gt; [(String, KnownExtension)]
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">:</span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'A'</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'Z'</span></span><span class="hs-special">)</span><span>
</span><span id="line-690"></span><span>    </span><span class="hs-special">[</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Char
forall a. [a] -&gt; a
</span><span class="hs-identifier hs-var">head</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386590"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386590"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386589"><span class="hs-identifier hs-var">extension</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-691"></span><span>    </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621679386589"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386589"><span class="hs-identifier hs-var">extension</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">Int -&gt; KnownExtension
forall a. Enum a =&gt; Int -&gt; a
</span><span class="hs-identifier hs-var">toEnum</span></span><span> </span><span class="annot"><span class="annottext">Int
</span><span class="hs-number">0</span></span><span> </span><span class="hs-glyph">..</span><span class="hs-special">]</span><span>
</span><span id="line-692"></span><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679386590"><span class="annot"><span class="annottext">str :: String
</span><a href="#local-6989586621679386590"><span class="hs-identifier hs-var hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386589"><span class="hs-identifier hs-var">extension</span></a></span><span> </span><span class="hs-special">]</span><span>
</span><span id="line-693"></span><span>
</span><span id="line-694"></span><span class="hs-comment">-- | Parse an enabled or disabled extension; returns</span><span>
</span><span id="line-695"></span><span class="hs-comment">-- 'UnknownExtension' if the parse fails.</span><span>
</span><span id="line-696"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#parseExtension"><span class="hs-identifier hs-type">parseExtension</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span>
</span><span id="line-697"></span><span id="parseExtension"><span class="annot"><span class="annottext">parseExtension :: String -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#parseExtension"><span class="hs-identifier hs-var hs-var">parseExtension</span></a></span></span><span> </span><span id="local-6989586621679386587"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386587"><span class="hs-identifier hs-var">str</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Extension -&gt; Maybe Extension -&gt; Extension
forall a. a -&gt; Maybe a -&gt; a
</span><span class="hs-identifier hs-var">fromMaybe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#UnknownExtension"><span class="hs-identifier hs-var">UnknownExtension</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386587"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Maybe Extension -&gt; Extension) -&gt; Maybe Extension -&gt; Extension
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-698"></span><span>      </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-var">EnableExtension</span></a></span><span>  </span><span class="annot"><span class="annottext">(KnownExtension -&gt; Extension)
-&gt; Maybe KnownExtension -&gt; Maybe Extension
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe KnownExtension
forall a. Read a =&gt; String -&gt; Maybe a
</span><a href="Language.Haskell.Exts.Extension.html#readMay"><span class="hs-identifier hs-var">readMay</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386587"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-699"></span><span>  </span><span class="annot"><span class="annottext">Maybe Extension -&gt; Maybe Extension -&gt; Maybe Extension
forall (f :: * -&gt; *) a. Alternative f =&gt; f a -&gt; f a -&gt; f a
</span><span class="hs-operator hs-var">&lt;|&gt;</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; Extension
</span><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-var">DisableExtension</span></a></span><span> </span><span class="annot"><span class="annottext">(KnownExtension -&gt; Extension)
-&gt; Maybe KnownExtension -&gt; Maybe Extension
forall (f :: * -&gt; *) a b. Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b
</span><span class="hs-operator hs-var">&lt;$&gt;</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String -&gt; Maybe KnownExtension
forall a. Read a =&gt; String -&gt; Maybe a
</span><a href="Language.Haskell.Exts.Extension.html#readMay"><span class="hs-identifier hs-var">readMay</span></a></span><span> </span><span class="annot"><span class="annottext">(String -&gt; Maybe KnownExtension)
-&gt; Maybe String -&gt; Maybe KnownExtension
forall (m :: * -&gt; *) a b. Monad m =&gt; (a -&gt; m b) -&gt; m a -&gt; m b
</span><span class="hs-operator hs-var">=&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String
</span><a href="#local-6989586621679386583"><span class="hs-identifier hs-var">dropNo</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386587"><span class="hs-identifier hs-var">str</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-700"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-701"></span><span>    </span><span id="local-6989586621679386583"><span class="annot"><span class="annottext">dropNo :: String -&gt; Maybe String
</span><a href="#local-6989586621679386583"><span class="hs-identifier hs-var hs-var">dropNo</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'N'</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span class="annot"><span class="annottext">Char
</span><span class="hs-char">'o'</span></span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span id="local-6989586621679386582"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386582"><span class="hs-identifier hs-var">rest</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String -&gt; Maybe String
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386582"><span class="hs-identifier hs-var">rest</span></a></span><span>
</span><span id="line-702"></span><span>    </span><span class="annot"><a href="#local-6989586621679386583"><span class="hs-identifier hs-var">dropNo</span></a></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-identifier">_</span></span><span>              </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe String
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-703"></span><span>
</span><span id="line-704"></span><span class="hs-comment">-- | Pretty print an extension. Disabled extensions are prefixed with</span><span>
</span><span id="line-705"></span><span class="hs-comment">-- \'No\'.</span><span>
</span><span id="line-706"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyExtension"><span class="hs-identifier hs-type">prettyExtension</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span>
</span><span id="line-707"></span><span id="prettyExtension"><span class="annot"><span class="annottext">prettyExtension :: Extension -&gt; String
</span><a href="Language.Haskell.Exts.Extension.html#prettyExtension"><span class="hs-identifier hs-var hs-var">prettyExtension</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-type">EnableExtension</span></a></span><span>  </span><span id="local-6989586621679386581"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386581"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386581"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-708"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyExtension"><span class="hs-identifier hs-var">prettyExtension</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-type">DisableExtension</span></a></span><span> </span><span id="local-6989586621679386580"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386580"><span class="hs-identifier hs-var">ext</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;No&quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; String
forall a. Show a =&gt; a -&gt; String
</span><span class="hs-identifier hs-var">show</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386580"><span class="hs-identifier hs-var">ext</span></a></span><span>
</span><span id="line-709"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#prettyExtension"><span class="hs-identifier hs-var">prettyExtension</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnknownExtension"><span class="hs-identifier hs-type">UnknownExtension</span></a></span><span> </span><span id="local-6989586621679386579"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386579"><span class="hs-identifier hs-var">str</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386579"><span class="hs-identifier hs-var">str</span></a></span><span>
</span><span id="line-710"></span><span>
</span><span id="line-711"></span><span id="local-6989586621679387070"><span class="annot"><a href="Language.Haskell.Exts.Extension.html#readMay"><span class="hs-identifier hs-type">readMay</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Read</span></span><span> </span><span class="annot"><a href="#local-6989586621679387070"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">String</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Maybe</span></span><span> </span><span class="annot"><a href="#local-6989586621679387070"><span class="hs-identifier hs-type">a</span></a></span></span><span>
</span><span id="line-712"></span><span id="readMay"><span class="annot"><span class="annottext">readMay :: String -&gt; Maybe a
</span><a href="Language.Haskell.Exts.Extension.html#readMay"><span class="hs-identifier hs-var hs-var">readMay</span></a></span></span><span> </span><span id="local-6989586621679386578"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386578"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679386577"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="hs-glyph">|</span><span> </span><span class="hs-special">(</span><span id="local-6989586621679386577"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679386577"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">,</span><span id="local-6989586621679386576"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386576"><span class="hs-identifier hs-var">t</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReadS a
forall a. Read a =&gt; ReadS a
</span><span class="hs-identifier hs-var">reads</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386578"><span class="hs-identifier hs-var">s</span></a></span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">,</span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;&quot;</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">ReadS String
</span><span class="hs-identifier hs-var">lex</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386576"><span class="hs-identifier hs-var">t</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-713"></span><span>                </span><span class="hs-special">[</span><span id="local-6989586621679386573"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679386573"><span class="hs-identifier hs-var">x</span></a></span></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">a -&gt; Maybe a
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621679386573"><span class="hs-identifier hs-var">x</span></a></span><span>
</span><span id="line-714"></span><span>                </span><span class="annot"><span class="annottext">[a]
</span><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">Maybe a
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-715"></span><span>
</span><span id="line-716"></span><span class="hs-comment">{-------------------------------------------
 -- Transform a 'Language', and possibly a modifying set of'Extension's, into a list
 -- of 'KnownExtension's, to be interpreted as modifying the language you get
 -- when all known extensions are disabled.
 -- Extensions are interpreted in a right-biased fashion, so the last instance
 -- of an occurence of 'EnableExtension' or 'DisableExtension' for a given
 -- 'KnownExtension' takes precedence.
 -------------------------------------------}</span><span>
</span><span id="line-724"></span><span>
</span><span id="line-725"></span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#toExtensionList"><span class="hs-identifier hs-type">toExtensionList</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Language"><span class="hs-identifier hs-type">Language</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-726"></span><span id="toExtensionList"><span class="annot"><span class="annottext">toExtensionList :: Language -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#toExtensionList"><span class="hs-identifier hs-var hs-var">toExtensionList</span></a></span></span><span> </span><span id="local-6989586621679386572"><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386572"><span class="hs-identifier hs-var">lang</span></a></span></span><span> </span><span id="local-6989586621679386571"><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386571"><span class="hs-identifier hs-var">exts'</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-727"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621679386570"><span class="annot"><span class="annottext">langKes :: [KnownExtension]
</span><a href="#local-6989586621679386570"><span class="hs-identifier hs-var hs-var">langKes</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">Language
</span><a href="#local-6989586621679386572"><span class="hs-identifier hs-var">lang</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-728"></span><span>                    </span><span class="annot"><span class="annottext">Language
</span><a href="Language.Haskell.Exts.Extension.html#Haskell98"><span class="hs-identifier hs-var">Haskell98</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#NPlusKPatterns"><span class="hs-identifier hs-var">NPlusKPatterns</span></a></span><span class="annot"><span class="annottext">KnownExtension -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#allLangDefault"><span class="hs-identifier hs-var">allLangDefault</span></a></span><span>
</span><span id="line-729"></span><span>                    </span><span class="annot"><span class="annottext">Language
</span><a href="Language.Haskell.Exts.Extension.html#Haskell2010"><span class="hs-identifier hs-var">Haskell2010</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#DoAndIfThenElse"><span class="hs-identifier hs-var">DoAndIfThenElse</span></a></span><span>
</span><span id="line-730"></span><span>                                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#PatternGuards"><span class="hs-identifier hs-var">PatternGuards</span></a></span><span>
</span><span id="line-731"></span><span>                                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#ForeignFunctionInterface"><span class="hs-identifier hs-var">ForeignFunctionInterface</span></a></span><span>
</span><span id="line-732"></span><span>                                   </span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="Language.Haskell.Exts.Extension.html#EmptyDataDecls"><span class="hs-identifier hs-var">EmptyDataDecls</span></a></span><span>
</span><span id="line-733"></span><span>                                   </span><span class="hs-special">]</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#allLangDefault"><span class="hs-identifier hs-var">allLangDefault</span></a></span><span>
</span><span id="line-734"></span><span>                    </span><span class="annot"><span class="annottext">Language
</span><a href="Language.Haskell.Exts.Extension.html#HaskellAllDisabled"><span class="hs-identifier hs-var">HaskellAllDisabled</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span>
</span><span id="line-735"></span><span>                    </span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#UnknownLanguage"><span class="hs-identifier hs-type">UnknownLanguage</span></a></span><span> </span><span id="local-6989586621679386569"><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386569"><span class="hs-identifier hs-var">s</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-736"></span><span>                        </span><span class="annot"><span class="annottext">String -&gt; [KnownExtension]
forall a. HasCallStack =&gt; String -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">(String -&gt; [KnownExtension]) -&gt; String -&gt; [KnownExtension]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">String
</span><span class="hs-string">&quot;toExtensionList: Unknown language &quot;</span></span><span> </span><span class="annot"><span class="annottext">String -&gt; ShowS
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">String
</span><a href="#local-6989586621679386569"><span class="hs-identifier hs-var">s</span></a></span><span>
</span><span id="line-737"></span><span class="hs-comment">{-
        addExts = [ ke | EnableExtension  ke &lt;- exts ]
        remExts = [ ke | DisableExtension ke &lt;- exts ]
     in impliesExts $ nub $ (langKes ++ addExts) \\ remExts
-}</span><span>
</span><span id="line-742"></span><span>  </span><span class="hs-keyword">in</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension]
</span><a href="Language.Haskell.Exts.Extension.html#impliesExts"><span class="hs-identifier hs-var">impliesExts</span></a></span><span> </span><span class="annot"><span class="annottext">([KnownExtension] -&gt; [KnownExtension])
-&gt; [KnownExtension] -&gt; [KnownExtension]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [KnownExtension]
forall a. Eq a =&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">nub</span></span><span> </span><span class="annot"><span class="annottext">([KnownExtension] -&gt; [KnownExtension])
-&gt; [KnownExtension] -&gt; [KnownExtension]
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386570"><span class="hs-identifier hs-var">langKes</span></a></span><span> </span><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386571"><span class="hs-identifier hs-var">exts'</span></a></span><span>
</span><span id="line-743"></span><span>    </span><span class="hs-keyword">where</span><span> </span><span class="annot"><a href="#local-6989586621679386567"><span class="hs-identifier hs-type">go</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#Extension"><span class="hs-identifier hs-type">Extension</span></a></span><span class="hs-special">]</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">[</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#KnownExtension"><span class="hs-identifier hs-type">KnownExtension</span></a></span><span class="hs-special">]</span><span>
</span><span id="line-744"></span><span>          </span><span id="local-6989586621679386567"><span class="annot"><span class="annottext">go :: [KnownExtension] -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386567"><span class="hs-identifier hs-var hs-var">go</span></a></span></span><span> </span><span id="local-6989586621679386566"><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386566"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386566"><span class="hs-identifier hs-var">acc</span></a></span><span>
</span><span id="line-745"></span><span>          </span><span class="annot"><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679386565"><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386565"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#DisableExtension"><span class="hs-identifier hs-type">DisableExtension</span></a></span><span> </span><span id="local-6989586621679386564"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386564"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679386563"><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386563"><span class="hs-identifier hs-var">exts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">(KnownExtension -&gt; Bool) -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
</span><span class="hs-identifier hs-var">filter</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension -&gt; KnownExtension -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">/=</span></span><span> </span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386564"><span class="hs-identifier hs-var">x</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386565"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386563"><span class="hs-identifier hs-var">exts</span></a></span><span>
</span><span id="line-746"></span><span>          </span><span class="annot"><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679386561"><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386561"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Language.Haskell.Exts.Extension.html#EnableExtension"><span class="hs-identifier hs-type">EnableExtension</span></a></span><span>  </span><span id="local-6989586621679386560"><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386560"><span class="hs-identifier hs-var">x</span></a></span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679386559"><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386559"><span class="hs-identifier hs-var">exts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">KnownExtension
</span><a href="#local-6989586621679386560"><span class="hs-identifier hs-var">x</span></a></span><span> </span><span class="annot"><span class="annottext">KnownExtension -&gt; [KnownExtension] -&gt; [KnownExtension]
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386561"><span class="hs-identifier hs-var">acc</span></a></span><span class="hs-special">)</span><span>           </span><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386559"><span class="hs-identifier hs-var">exts</span></a></span><span>
</span><span id="line-747"></span><span>          </span><span class="hs-comment">-- We just throw away UnknownExtensions</span><span>
</span><span id="line-748"></span><span>          </span><span class="annot"><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span id="local-6989586621679386558"><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386558"><span class="hs-identifier hs-var">acc</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Extension
</span><span class="hs-identifier">_</span></span><span> </span><span class="annot"><span class="hs-glyph hs-type">:</span></span><span> </span><span id="local-6989586621679386557"><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386557"><span class="hs-identifier hs-var">exts</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">[KnownExtension] -&gt; [Extension] -&gt; [KnownExtension]
</span><a href="#local-6989586621679386567"><span class="hs-identifier hs-var">go</span></a></span><span> </span><span class="annot"><span class="annottext">[KnownExtension]
</span><a href="#local-6989586621679386558"><span class="hs-identifier hs-var">acc</span></a></span><span> </span><span class="annot"><span class="annottext">[Extension]
</span><a href="#local-6989586621679386557"><span class="hs-identifier hs-var">exts</span></a></span><span>
</span><span id="line-749"></span></pre></body></html>