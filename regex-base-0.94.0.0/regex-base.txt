-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Common "Text.Regex.*" API for Regex matching
--   
--   This package doesn't provide the ability to do regex matching, but
--   instead provides the type-classes that constitute the abstract API
--   that is implemented by <tt>regex-*</tt> backends such as
--   
--   <ul>
--   <li><a>regex-posix</a></li>
--   <li><a>regex-parsec</a></li>
--   <li><a>regex-dfa</a></li>
--   <li><a>regex-tdfa</a></li>
--   <li><a>regex-pcre</a></li>
--   </ul>
--   
--   See also <a>https://wiki.haskell.org/Regular_expressions</a> for more
--   information.
@package regex-base
@version 0.94.0.0


-- | Classes and instances for Regex matching.
--   
--   All the classes are declared here, and some common type aliases, and
--   the MatchResult data type.
--   
--   The only instances here are for <a>Extract</a> <a>String</a>,
--   <a>Extract</a> <a>ByteString</a>, and <a>Extract</a> <a>Text</a>.
--   There are no data values. The <a>RegexContext</a> instances are in
--   <a>Text.Regex.Base.Context</a>, except for ones which run afoul of a
--   repeated variable (<a>RegexContext</a> regex a a), which are defined
--   in each modules' String and ByteString modules.
module Text.Regex.Base.RegexLike

-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int

-- | non-negative length of a match
type MatchLength = Int

-- | 0 based array, with 0th index indicating the full match. If the full
--   match location is not available, represent as (0,0).
type MatchArray = Array Int (MatchOffset, MatchLength)
type MatchText source = Array Int (source, (MatchOffset, MatchLength))

-- | This is the same as the type from JRegex.
data MatchResult a
MR :: a -> a -> a -> [a] -> Array Int a -> MatchResult a
[mrBefore] :: MatchResult a -> a
[mrMatch] :: MatchResult a -> a
[mrAfter] :: MatchResult a -> a
[mrSubList] :: MatchResult a -> [a]
[mrSubs] :: MatchResult a -> Array Int a

-- | Rather than carry them around spearately, the options for how to
--   execute a regex are kept as part of the regex. There are two types of
--   options. Those that can only be specified at compilation time and
--   never changed are CompOpt. Those that can be changed later and affect
--   how matching is performed are ExecOpt. The actually types for these
--   depend on the backend.
class RegexOptions regex compOpt execOpt | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt
blankCompOpt :: RegexOptions regex compOpt execOpt => compOpt
blankExecOpt :: RegexOptions regex compOpt execOpt => execOpt
defaultCompOpt :: RegexOptions regex compOpt execOpt => compOpt
defaultExecOpt :: RegexOptions regex compOpt execOpt => execOpt

-- | forget old flags and use new ones
setExecOpts :: RegexOptions regex compOpt execOpt => execOpt -> regex -> regex

-- | retrieve the current flags
getExecOpts :: RegexOptions regex compOpt execOpt => regex -> execOpt

-- | RegexMaker captures the creation of the compiled regular expression
--   from a source type and an option type. <a>makeRegexM</a> and
--   <a>makeRegexM</a> report parse error using <tt>MonadError</tt>,
--   usually (Either String regex).
--   
--   The <a>makeRegex</a> function has a default implementation that
--   depends on makeRegexOpts and used <a>defaultCompOpt</a> and
--   <a>defaultExecOpt</a>. Similarly for <a>makeRegexM</a> and
--   <a>makeRegexOptsM</a>.
--   
--   There are also default implementaions for <a>makeRegexOpts</a> and
--   <a>makeRegexOptsM</a> in terms of each other. So a minimal instance
--   definition needs to only define one of these, hopefully
--   <a>makeRegexOptsM</a>.
class (RegexOptions regex compOpt execOpt) => RegexMaker regex compOpt execOpt source | regex -> compOpt execOpt, compOpt -> regex execOpt, execOpt -> regex compOpt

-- | make using the defaultCompOpt and defaultExecOpt
makeRegex :: RegexMaker regex compOpt execOpt source => source -> regex

-- | Specify your own options
makeRegexOpts :: RegexMaker regex compOpt execOpt source => compOpt -> execOpt -> source -> regex

-- | make using the defaultCompOpt and defaultExecOpt, reporting errors
--   with fail
makeRegexM :: (RegexMaker regex compOpt execOpt source, MonadFail m) => source -> m regex

-- | Specify your own options, reporting errors with fail
makeRegexOptsM :: (RegexMaker regex compOpt execOpt source, MonadFail m) => compOpt -> execOpt -> source -> m regex

-- | RegexLike is parametrized on a regular expression type and a source
--   type to run the matching on.
--   
--   There are default implementations: matchTest and matchOnceText use
--   matchOnce; matchCount and matchAllText use matchAll. matchOnce uses
--   matchOnceText and matchAll uses matchAllText. So a minimal complete
--   instance need to provide at least (matchOnce or matchOnceText) and
--   (matchAll or matchAllText). Additional definitions are often provided
--   where they will increase efficiency.
--   
--   <pre>
--   [ c | let notVowel = makeRegex "[^aeiou]" :: Regex, c &lt;- ['a'..'z'], matchTest notVowel [c]  ]
--   
--   "bcdfghjklmnpqrstvwxyz"
--   </pre>
--   
--   The strictness of these functions is instance dependent.
class (Extract source) => RegexLike regex source

-- | This returns the first match in the source (it checks the whole
--   source, not just at the start). This returns an array of
--   (offset,length) index pairs for the match and captured substrings. The
--   offset is 0-based. A (-1) for an offset means a failure to match. The
--   lower bound of the array is 0, and the 0th element is the
--   (offset,length) for the whole match.
matchOnce :: RegexLike regex source => regex -> source -> Maybe MatchArray

-- | matchAll returns a list of matches. The matches are in order and do
--   not overlap. If any match succeeds but has 0 length then this will be
--   the last match in the list.
matchAll :: RegexLike regex source => regex -> source -> [MatchArray]

-- | matchCount returns the number of non-overlapping matches returned by
--   matchAll.
matchCount :: RegexLike regex source => regex -> source -> Int

-- | matchTest return True if there is a match somewhere in the source (it
--   checks the whole source not just at the start).
matchTest :: RegexLike regex source => regex -> source -> Bool

-- | This is matchAll with the actual subsections of the source instead of
--   just the (offset,length) information.
matchAllText :: RegexLike regex source => regex -> source -> [MatchText source]

-- | This can return a tuple of three items: the source before the match,
--   an array of the match and captured substrings (with their indices),
--   and the source after the match.
matchOnceText :: RegexLike regex source => regex -> source -> Maybe (source, MatchText source, source)

-- | RegexContext is the polymorphic interface to do matching. Since
--   <tt>target</tt> is polymorphic you may need to suply the type
--   explicitly in contexts where it cannot be inferred.
--   
--   The monadic <a>matchM</a> version uses <tt>fail</tt> to report when
--   the <tt>regex</tt> has no match in <tt>source</tt>. Two examples:
--   
--   Here the contest <a>Bool</a> is inferred:
--   
--   <pre>
--   [ c | let notVowel = makeRegex "[^aeiou]" :: Regex, c &lt;- ['a'..'z'], match notVowel [c]  ]
--   
--   "bcdfghjklmnpqrstvwxyz"
--   </pre>
--   
--   Here the context '[String]' must be supplied:
--   
--   <pre>
--   let notVowel = (makeRegex "[^aeiou]" :: Regex )
--   in do { c &lt;- ['a'..'z'] ; matchM notVowel [c] } :: [String]
--   
--   ["b","c","d","f","g","h","j","k","l","m","n","p","q","r","s","t","v","w","x","y","z"]
--   </pre>
class (RegexLike regex source) => RegexContext regex source target
match :: RegexContext regex source target => regex -> source -> target
matchM :: (RegexContext regex source target, MonadFail m) => regex -> source -> m target

-- | Extract allows for indexing operations on String or ByteString.
class Extract source

-- | before is a renamed "take"
before :: Extract source => Int -> source -> source

-- | after is a renamed "drop"
after :: Extract source => Int -> source -> source

-- | For when there is no match, this can construct an empty data value
empty :: Extract source => source

-- | extract takes an offset and length and has a default implementation of
--   <tt>extract (off,len) source = before len (after off source)</tt>
extract :: Extract source => (Int, Int) -> source -> source

-- | Used in results of RegexContext instances
newtype AllSubmatches f b
AllSubmatches :: f b -> AllSubmatches f b
[getAllSubmatches] :: AllSubmatches f b -> f b

-- | Used in results of RegexContext instances
newtype AllTextSubmatches f b
AllTextSubmatches :: f b -> AllTextSubmatches f b
[getAllTextSubmatches] :: AllTextSubmatches f b -> f b

-- | Used in results of RegexContext instances
newtype AllMatches f b
AllMatches :: f b -> AllMatches f b
[getAllMatches] :: AllMatches f b -> f b

-- | Used in results of RegexContext instances
newtype AllTextMatches f b
AllTextMatches :: f b -> AllTextMatches f b
[getAllTextMatches] :: AllTextMatches f b -> f b
instance Text.Regex.Base.RegexLike.Extract GHC.Base.String
instance Text.Regex.Base.RegexLike.Extract Data.ByteString.Internal.ByteString
instance Text.Regex.Base.RegexLike.Extract Data.ByteString.Lazy.Internal.ByteString
instance Text.Regex.Base.RegexLike.Extract (Data.Sequence.Internal.Seq a)
instance Text.Regex.Base.RegexLike.Extract Data.Text.Internal.Text
instance Text.Regex.Base.RegexLike.Extract Data.Text.Internal.Lazy.Text


-- | This is a module of instances of <a>RegexContext</a> (defined in
--   Text.Regex.Base.RegexLike). Nothing else is exported. This is usually
--   imported via the Text.Regex.Base convenience package which itself is
--   re-exported from newer Text.Regex.XXX modules provided by the
--   different regex-xxx backends.
--   
--   These instances work for all the supported types and backends
--   interchangably. These instances provide the different results that can
--   be gotten from a match or matchM operation (often via the <tt>=~</tt>
--   and <tt>=~~</tt> operators with combine <tt>makeRegex</tt> with
--   <tt>match</tt> and <tt>matchM</tt> respectively). This module name is
--   Context because they operators are context dependent: use them in a
--   context that expects an Int and you get a count of matches, use them
--   in a Bool context and get True if there is a match, etc.
--   
--   <tt>RegexContext a b c</tt> takes a regular expression suppied in a
--   type <tt>a</tt> generated by <tt>RegexMaker</tt> and a target text
--   supplied in type <tt>b</tt> to a result type <tt>c</tt> using the
--   <a>match</a> class function. The <a>matchM</a> class function works
--   like <a>match</a> unless there is no match found, in which case it
--   calls <a>fail</a> in the (arbitrary) monad context.
--   
--   There are a few type synonyms from RegexLike that are used here:
--   
--   <pre>
--   -- | 0 based index from start of source, or (-1) for unused
--   type MatchOffset = Int
--   -- | non-negative length of a match
--   type MatchLength = Int
--   type MatchArray = Array Int (MatchOffset, MatchLength)
--   type MatchText source = Array Int (source, (MatchOffset, MatchLength))
--   </pre>
--   
--   There are also a few newtypes that used to prevent any possible
--   overlap of types, which were not needed for GHC's late overlap
--   detection but are needed for use in Hugs.
--   
--   <pre>
--   newtype AllSubmatches f b = AllSubmatches {getAllSubmatches :: (f b)}
--   newtype AllTextSubmatches f b = AllTextSubmatches {getAllTextSubmatches :: (f b)}
--   newtype AllMatches f b = AllMatches {getAllMatches :: (f b)}
--   newtype AllTextMatches f b = AllTextMatches {getAllTextMatches :: (f b) }
--   </pre>
--   
--   The newtypes' <tt>f</tt> parameters are the containers, usually
--   <tt>[]</tt> or <tt>Array Int</tt>, (where the arrays all have lower
--   bound 0).
--   
--   The two *Submatches newtypes return only information on the first
--   match. The other two newtypes return information on all the
--   non-overlapping matches. The two *Text* newtypes are used to mark
--   result types that contain the same type as the target text.
--   
--   Where provided, noncaptured submatches will have a
--   <tt>MatchOffset</tt> of (-1) and non-negative otherwise. The semantics
--   of submatches depend on the backend and its compile and execution
--   options. Where provided, <tt>MatchLength</tt> will always be
--   non-negative. Arrays with no elements are returned with bounds of
--   (1,0). Arrays with elements will have a lower bound of 0.
--   
--   XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX
--   
--   These are for finding the first match in the target text:
--   
--   <tt> RegexContext a b Bool </tt> : Whether there is any match or not.
--   
--   <tt> RegexContext a b () </tt> : Useful as a guard with
--   <tt>matchM</tt> or <tt>=~~</tt> in a monad, since failure to match
--   calls <a>fail</a>.
--   
--   <tt> RegexContext a b b </tt> : This returns the text of the whole
--   match. It will return <a>empty</a> from the <a>Extract</a> type class
--   if there is no match. These are defined in each backend module, but
--   documented here for convenience.
--   
--   <tt> RegexContext a b (MatchOffset,MatchLength) </tt> : This returns
--   the initial index and length of the whole match. MatchLength will
--   always be non-negative, and 0 for a failed match.
--   
--   <tt> RegexContext a b (MatchResult b) </tt> : The <a>MatchResult</a>
--   structure with details for the match. This is the structure copied
--   from the old <tt>JRegex</tt> pacakge.
--   
--   <tt> RegexContext a b (b, b, b) </tt> : The text before the match, the
--   text of the match, the text after the match
--   
--   <tt> RegexContext a b (b, MatchText b, b) </tt> : The text before the
--   match, the details of the match, and the text after the match
--   
--   <tt> RegexContext a b (b, b, b, [b]) </tt> : The text before the
--   match, the text of the match, the text after the match, and a list of
--   the text of the 1st and higher sub-parts of the match. This is the
--   same return value as used in the old <tt>Text.Regex</tt> API.
--   
--   Two containers of the submatch offset information:
--   
--   <tt> RegexContext a b MatchArray </tt> : Array of
--   <tt>(MatchOffset,MatchLength)</tt> for all the sub matches. The whole
--   match is at the intial 0th index. Noncaptured submatches will have a
--   <tt>MatchOffset</tt> of (-1) The array will have no elements and
--   bounds (1,0) if there is no match.
--   
--   <tt> RegexContext a b (AllSubmatches [] (MatchOffset,MatchLength)
--   </tt> : List of <tt>(MatchOffset,MatchLength)</tt> The whole match is
--   the first element, the rest are the submatches (if any) in order. The
--   list is empty if there is no match.
--   
--   Two containers of the submatch text and offset information:
--   
--   <pre>
--   RegexContext a b (AllTextSubmatches (Array Int) (b, (MatchOffset, MatchLength)))
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextSubmatches [] (b, (MatchOffset, MatchLength)))
--   </pre>
--   
--   Two containers of the submatch text information:
--   
--   <pre>
--   RegexContext a b (AllTextSubmatches [] b)
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextSubmatches (Array Int) b)
--   </pre>
--   
--   These instances are for all the matches (non-overlapping). Note that
--   backends are supposed to supply <a>RegexLike</a> instances for which
--   the default <a>matchAll</a> and <a>matchAllText</a> stop searching
--   after returning any successful but empty match.
--   
--   <tt> RegexContext a b Int </tt> : The number of matches, non-negative.
--   
--   Two containers for locations of all matches:
--   
--   <pre>
--   RegexContext a b (AllMatches [] (MatchOffset, MatchLength))
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllMatches (Array Int) (MatchOffset,MatchLength))
--   </pre>
--   
--   Two containers for the locations of all matches and their submatches:
--   
--   <tt> RegexContext a b [MatchArray] </tt> :
--   
--   <pre>
--   RegexContext a b (AllMatches (Array Int) MatchArray)
--   </pre>
--   
--   Two containers for the text and locations of all matches and their
--   submatches:
--   
--   <pre>
--   RegexContext a b [MatchText b]
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextMatches (Array Int) (MatchText b))
--   </pre>
--   
--   Two containers for text of all matches: <tt> RegexContext a b
--   (AllTextMatches [] b) </tt>
--   
--   <pre>
--   RegexContext a b (AllTextMatches (Array Int) b)
--   </pre>
--   
--   Four containers for text of all matches and their submatches:
--   
--   <pre>
--   RegexContext a b [[b]]
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextMatches (Array Int) [b])
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextMatches [] (Array Int b))
--   </pre>
--   
--   <pre>
--   RegexContext a b (AllTextMatches (Array Int) (Array Int b))
--   </pre>
--   
--   Unused matches are <a>empty</a> (defined via <a>Extract</a>)
module Text.Regex.Base.Context
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b GHC.Types.Bool
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b ()
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b GHC.Types.Int
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.MatchResult b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, Text.Regex.Base.RegexLike.MatchText b, b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, b, b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (b, b, b, [b])
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b Text.Regex.Base.RegexLike.MatchArray
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllSubmatches [] (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches (GHC.Arr.Array GHC.Types.Int) (b, (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches [] (b, (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength)))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches [] b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextSubmatches (GHC.Arr.Array GHC.Types.Int) b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches [] (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches (GHC.Arr.Array GHC.Types.Int) (Text.Regex.Base.RegexLike.MatchOffset, Text.Regex.Base.RegexLike.MatchLength))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [Text.Regex.Base.RegexLike.MatchArray]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllMatches (GHC.Arr.Array GHC.Types.Int) Text.Regex.Base.RegexLike.MatchArray)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [Text.Regex.Base.RegexLike.MatchText b]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) (Text.Regex.Base.RegexLike.MatchText b))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches [] b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) b)
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b [[b]]
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) [b])
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches [] (GHC.Arr.Array GHC.Types.Int b))
instance Text.Regex.Base.RegexLike.RegexLike a b => Text.Regex.Base.RegexLike.RegexContext a b (Text.Regex.Base.RegexLike.AllTextMatches (GHC.Arr.Array GHC.Types.Int) (GHC.Arr.Array GHC.Types.Int b))


-- | Classes and instances for Regex matching.
--   
--   This module merely imports and re-exports the common part of the new
--   api: <a>Text.Regex.Base.RegexLike</a> and
--   <a>Text.Regex.Base.Context</a>.
--   
--   To see what result types the instances of RegexContext can produce,
--   please read the <a>Text.Regex.Base.Context</a> haddock documentation.
--   
--   This does not provide any of the backends, just the common interface
--   they all use. The modules which provide the backends and their cabal
--   packages are:
--   
--   <ul>
--   <li><tt>Text.Regex.Posix</tt> from regex-posix</li>
--   <li><tt>Text.Regex</tt> from regex-compat (uses regex-posix)</li>
--   <li><tt>Text.Regex.Parsec</tt> from regex-parsec</li>
--   <li><tt>Text.Regex.DFA</tt> from regex-dfa</li>
--   <li><tt>Text.Regex.PCRE</tt> from regex-pcre</li>
--   <li><tt>Test.Regex.TRE</tt> from regex-tre</li>
--   </ul>
--   
--   In fact, just importing one of the backends is adequate, you do not
--   also need to import this module.
--   
--   <h2>Example</h2>
--   
--   The code below
--   
--   <pre>
--   import Text.Regex.Base
--   import Text.Regex.Posix((=~),(=~~)) -- or DFA or PCRE or PosixRE
--   
--   main = let b :: Bool
--              b = ("abaca" =~ "(.)a")
--              c :: [MatchArray]
--              c = ("abaca" =~ "(.)a")
--              d :: Maybe (String,String,String,[String])
--              d = ("abaca" =~~ "(.)a")
--          in do print b
--                print c
--                print d
--   </pre>
--   
--   will output
--   
--   <pre>
--   True
--   [array (0,1) [(0,(1,2)),(1,(1,1))],array (0,1) [(0,(3,2)),(1,(3,1))]]
--   Just ("a","ba","ca",["b"])
--   </pre>
module Text.Regex.Base
getVersion_Text_Regex_Base :: Version


-- | Helper functions for defining certain instances of RegexContext. These
--   help when defining instances of RegexContext with repeated types:
--   
--   <pre>
--   instance (RegexLike regex source) =&gt; RegexContext regex source source where
--   </pre>
--   
--   runs into overlapping restrictions. To avoid this I have each backend
--   define, for its own Regex type:
--   
--   <pre>
--   instance RegexContext Regex String String where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
--   
--   <pre>
--   instance RegexContext Regex ByteString ByteString where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
--   
--   <pre>
--   instance RegexContext Regex Text Text where
--     match = polymatch
--     matchM = polymatchM
--   </pre>
module Text.Regex.Base.Impl
polymatch :: RegexLike a b => a -> b -> b
polymatchM :: (RegexLike a b, MonadFail m) => a -> b -> m b
